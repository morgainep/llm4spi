[
   {
      "task_id": "HE0",
      "program-desc": "The program checks whether the given list z contains two elements whose sum is greater than a.\n\nExamples:\n    Pr_HE0([1.0, 2.0, 3.0], 6) = False\n    Pr_HE0([1.0, 2.8, 3.0, 4.0, 2.0, 5.0], 8.99) = True\n",
      "program": "def Pr_HE0(z:list[float], a:float) -> bool :\n    for idx, elem in enumerate(z):\n        for idx2, elem2 in enumerate(z):\n            if idx != idx2:\n                if elem + elem2 > a:\n                    return True\n\n    return False",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "r should be equivalent to whether z contains two elements whose sum is greater than a.\n\nExamples:\n    check_post_HE0(False, [1.0, 2.0, 3.0], 6) = True\n    check_post_HE0(True, [1.0, 2.8, 3.0, 4.0, 2.0, 5.0], 8.99) = True",
      "post_condition_incomplete": "def check_post_HE0(r:bool, z:list[float], a:float) -> bool :",
      "post_condition_solution": "def check_post_solution_HE0(r:bool, z:list[float], a:float) -> bool :\n    N = len(z)\n    expected = any([ any([ z[i] + z[k] > a\n                         for k in range(N) if k!=i ])\n                 for i in range(N)])\n    return r == expected",
      "post_condition_tests": "[\n    [False, [],0],\n    [False, [1],0],\n    [True, [1,0,8,-1], 8.99],\n    [False, [1,0,8,-1], 9],\n    \"===\",\n    [True, [1,1,1], 2],\n    [True, [0],0 ],\n    \"===\",\n    [True, [1,1,1,1], 1.99],\n    [True, [2,1,1,3], 4.99],\n    [True, [1.0, 2.8, 3.0, 4.0, 2.0, 5.0], 8.99],\n    [False, [9],0],\n    [False, [1,1,1,1], 0],\n    [False, [1.0, 2.0, 3.0], 5],\n    [False, [1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 4]\n    ]",
      "prg_CC": 5,
      "post_condition_CC": 4,
      "post_condition_complexity": "QQ"
   },
   {
      "task_id": "HE1",
      "program-desc": "The program is given a string s, assumed to contain one or more cp-segments.\nA cp-segment starts with '(' and is closed with ')' and recursively may contain\nmultiple inner cp-segments.\nThe program returns a list r,  consisting of the cp-segments of s as separate strings.\nSo, every r[i] is a  cp-segment of s.\nWhen joined, all the strings in r should give a string z that is equal to s.\n\nExamples:\n    Pr_HE1('()()') =  ['()', '()']\n    Pr_HE1('(())') =  ['(())' ]\n    Pr_HE1('(())(()())') =  ['(())', '(()())']\n",
      "program": "def Pr_HE1(s:str) -> list[str] :\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in s:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result",
      "pre_condition": "s is expected to contain one or more cp-segments. A cp-segment starts\nwith '(' and is closed with ')' and recursively may contain\nmultiple inner cp-segments.\n\nExamples:\n    check_pre_HE1('()') = True\n    check_pre_HE1('()()') = True\n    check_pre_HE1('(())') = True\n",
      "pre_condition_incomplete": "def check_pre_HE1(s:str) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE1(s:str) -> bool:\n    if len([c for c in s if c != '(' and c!=')']) > 0 :\n        return False\n    stack = 0 # keep track of how many '(' found so far wich have not been closed\n    for c in s:\n        if c == ')' and stack==0: return False\n        elif c == ')':\n            stack = stack-1\n        else :\n            stack = stack+1\n    return stack == 0",
      "pre_condition_tests": "[[''],['()'],['()(()())()'],[' ( ) '], ['('],\n                           \"===\", \"===\",\n                           ['()(())(()())'],\n                           [')()'],['())'],['()('],['(ab)'],['()()x']\n                           ]",
      "post_condition": "The list r should contain the cp-segments of s as separate strings.\nSo, every r[i] is a  cp-segment of s.\nA cp-segment starts with '(' and  is closed with ')' and recursively\nmay contain multiple inner cp-segments.\nWhen joined, all the strings in r should give a string z that is equal to s.\n\nExamples:\n    check_post_HE1(['()', '()'], '()()') = True\n    check_post_HE1(['(())' ], '(())') = True\n    check_post_HE1(['(())', '(()())'], '(())(()())') =  True\n",
      "post_condition_incomplete": "def check_post_HE1(r:list[str], s:str) -> bool:",
      "post_condition_solution": "def check_post_solution_HE1(r:list[str], s:str) -> bool:\n    z = [c for c in s if c != ' ']\n    if len(z) == 0 :\n        return len(r) == 0\n\n    def ok(segment:str) -> bool:\n        if len(segment) == 0 :\n            return False\n        if len([c for c in segment if c != '(' and c!=')']) > 0 :\n            return False\n        stack = 0 # keep track of how many '(' found so far wich have not been closed\n        while len(segment) > 0 :\n            c = segment[0]\n            segment = segment[1:]\n            if c == ')' and stack==0:\n                return False\n            elif c == ')':\n                stack = stack-1\n                if stack == 0 and len(segment)>0 :\n                    return False\n            else :\n                stack = stack+1\n        return stack == 0\n\n\n    return  all([ok(segment) for segment in r]) and  ''.join(r) == ''.join(z)",
      "post_condition_tests": "[ [[],''],\n                             [['()'],'()'],\n                             [['()','(()())','()'],'()(()())()'],\n                             \"===\",\n                             [['(())()' ] , '(())()'],\n                             [['(())' ] , '(())()'],\n                             \"===\",\n                             [['()','()'],'()()'],\n                             [['(())'],'(())'],\n                             [['()','(())','(()())'],'()(())(()())'],\n                             [['','()'],'()'],\n                             [['()(',')'],'()()'],\n                             [['()()'],'()()']\n                            ]",
      "prg_CC": 5,
      "pre_condition_CC": 9,
      "post_condition_CC": 6,
      "pre_condition_complexity": "NQ",
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE101",
      "program-desc": "Given a non-empty string consisting of non-empty words separated by either\na single comma, a colon, or a space, the program returns a sorted list of\nthe words in the string. Words that are non-alpha-nummeric or do not begin\nwith a letter are excluded.\n\nExamples:\n    Pr_HE101('hello:Anna Vienna') = ['Anna','hello','Vienna']\n    Pr_HE101('hello Anna!, it's me') = ['hello','me']\n",
      "program": "def Pr_HE101(s:str) -> list[str] :\n    seps = [' ', ',', ':']\n    words = []\n    w = ''\n    for c in s:\n        if c in seps:\n            if len(w)>0 and w.isalnum() and w[0].isalpha():\n                words.append(w)\n            w = ''\n        else:\n            w = w+c\n    if len(w) > 0 and w.isalnum() and w[0].isalpha():\n       words.append(w)\n    return sorted(words)",
      "pre_condition": "s should be a non-empty string consisting of non-empty words separated\nby either a single comma, a colon, or a space.\n\nExamples:\n    check_pre_HE101('hi,Anna! sup?') = True\n    check_pre_HE101('1:2') = True\n    check_pre_HE101('1  2') = False\n    check_pre_HE101(',1') = False\n    check_pre_HE101('1,') = False\n",
      "pre_condition_incomplete": "def check_pre_HE101(s:str) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE101(s:str) -> bool:\n    seps = [' ',',',':']\n    if len(s)==0 or s[0] in seps or s[-1] in seps:\n        return False\n    dseps = [c+d for c in seps for d in seps]\n    return not any([ ds in s for ds in dseps])",
      "pre_condition_tests": "[['hi,Anna! sup?'], ['1:2'], ['1  2'], [',1'], ['1,'], [''],\n                           \"===\",\"===\",\n                           ['aa,bb:cc dd'], ['a!'], ['a,:b'], ['::'], ['a,'], ['a,,b']\n                           ]",
      "post_condition": "Given a non-empty string s consisting of non-empty words separated by either\na single comma, a colon, or a space, the list r should be equal to the\nsorted list of the words in s.\nWords that are non-alpha-nummeric or do not begin with a letter are excluded.\n\nExamples:\n    check_post_HE101(['Anna','hello','vienna'],'hello:Anna vienna') = True\n    check_post_HE101(['hello','me'],'hello Anna!, it's me') = True\n",
      "post_condition_incomplete": "def check_post_HE101(r:list[str], s:str) -> bool:",
      "post_condition_solution": "def check_post_solution_HE101(r:list[str], s:str) -> bool:\n    z = s.split(' ')\n    z = sum([ x.split(',') for x in z], [])\n    z = sum([ x.split(':') for x in z], [])\n    z = [ w for w in z if w.isalnum() and w[0].isalpha()]\n    return r == sorted(z)",
      "post_condition_tests": "[ [['Anna','hello','vienna'],'hello:Anna vienna'],\n                               [['hello','me'],'hello Anna!, it\\'s me'],\n                               [['aa','bb','cc','dd'],'dd,cc:aa bb'],\n                               [['bb2'],'bb2,cc!:2aa'],\n                               [['aa2'],'aa2'],\n                               [[],'2aa'],\n                              \"===\",\n                              [['2aa','bb2','cc!'],'bb2:cc!:2aa'],\n                              [['aa bb','bb'],'bb:aa bb'],\n                              [['bb','aa'],'bb,aa'],\n                              \"===\",\n                              [['aa','bb','cc'],'cc bb,aa:00:123'],\n                              [['c0'],'c0:0c'],\n                              [[],'c!:0c,??'],\n                              [['hello world'],'hello world'],\n                              [['hello', 'anna'],'hello anna'],\n                              [['c'],'c,c,c'],\n                              [['1','2','3'],'1,2,3']\n                            ]",
      "prg_CC": 9,
      "pre_condition_CC": 7,
      "post_condition_CC": 6,
      "pre_condition_complexity": "NQ",
      "post_condition_complexity": "QQ"
   },
   {
      "task_id": "HE104",
      "program-desc": "Given a non-empty array s of integers and an integer k between 1 and 9 (inclusive),\nthe program returns a sorted array t consisting of all integers in s which have a\ndigit that is divisible by k.\nDigit 0 is considered as always divisible.\n\nExamples:\n    Pr_HE104([129, 24, -31], 3) = [-31, 129]\n",
      "program": "def Pr_HE104(s:list[int], k:int) -> list[int] :\n    r = []\n    for x in s:\n        digs = [int(d) for d in str(abs(x))]\n        if any(d==0 or d % k == 0 for d in digs):\n            r.append(x)\n    return sorted(r)\n",
      "pre_condition": "s should be a non-empty list and should be an integer between 1 and 9 (inclusive).\n",
      "pre_condition_incomplete": "def check_pre_HE104(s:list[int], k:int) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE104(s:list[int], k:int) -> bool:\n    return len(s)>0 and 1<= k <= 9",
      "pre_condition_tests": "[ [[1,2],1], [[1,2],9], [[],9], [[12],0], [[12],10],\n                           \"===\",\"===\",\n                           [[10,-10],9], [[-1,-10],1], [[100,10],-1], [[100,10],12]\n                           ]",
      "post_condition": "Given a non-empty array s of integers and an integer k between 1 and 9 (inclusive),\nthe list r should be equal to the sorted array t consisting of all integers in s which have a\ndigit that is divisible by k.\nDigit 0 is considered as always divisible.\n\nExamples:\n     check_post_HE104([-31, 129], [129, 24, -31], 3) = True\n",
      "post_condition_incomplete": "def check_post_HE104(r:list[int], s:list[int], k:int) -> bool:",
      "post_condition_solution": "def check_post_solution_HE104(r:list[int], s:list[int], k:int) -> bool:\n    return r == sorted([   x for x in s if any( dig==0 or int(dig) % k ==0  for dig in str(abs(x)))  ])",
      "post_condition_tests": "[\n         [[101,223], [111,223,101], 2],\n         [[-57,75], [-123, 75, -57], 5], [[], [-123, 85, -58], 7],\n         [[-31, 129], [129, 24, -31], 3],\n         \"===\",\n         [[],[21],2],  [[23, 21],[23, 21],2], [[21],[21],7],\n         \"===\",\n         [[-71,20,37,73], [37, 73, -71, 20], 7],\n         [[2773], [2773],3], [[], [1773],2],\n         [[],[10],3],  [[10,9],[10,9],3], [[21],[21],3]\n         ]",
      "prg_CC": 6,
      "pre_condition_CC": 2,
      "post_condition_CC": 5,
      "pre_condition_complexity": "S",
      "post_condition_complexity": "QQ"
   },
   {
      "task_id": "HE108",
      "program-desc": "Given an array qa of integers, the program returns the number of elements of qa\nwhich has the sum of digits > 0.\nIf a number is negative, then its first digit is considered to be negative:\ne.g. the first digit of -123 is -1.\n\nExamples:\n    Pr_HE108([-22]) = 0\n    Pr_HE108([-1, 11]) = 2\n",
      "program": "def Pr_HE108(qa) :\n    def digits_sum(n):\n        neg = 1\n        if n < 0:\n            n, neg = -1 * n, -1\n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in qa])))",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "retval should be equal to the number of integers in the list qa whose sum of digits > 0.\nIf a number is negative, then its first digit is considered to be negative:\ne.g. the first digit of -123 is -1.\n\nExamples:\n    check_post_HE108(0, [-22]) = True\n    check_post_HE108(2, [-1, 11]) = True",
      "post_condition_incomplete": "def check_post_HE108(retval,qa) -> bool:",
      "post_condition_solution": "def check_post_solution_HE108(retval,qa) -> bool:\n    def mysum(x:int) -> int :\n        z = [ int(digit) for digit in str(abs(x)) ]\n        if x<0 :\n            z0 = z[0] * -1\n            z.pop(0)\n            z.append(z0)\n        return sum(z)\n\n    return retval == len([x for x in qa if mysum(x)>0])",
      "post_condition_tests": "[[0,[]],[1,[-1, 11, -11]],[3,[1, 1, 2]],[2,[0,100,1]],\n                              [1, [-708, -11, -9]],\n                              \"===\",\n                              [2, [-11, 11]], [1, [200, -1002]],\n                              \"===\",\n                              [0,[-321, 0, -401]],[2,[13,-12,-622]],[3,[123,1]],[1,[18,-199]],[2,[0,-810211]]]\n",
      "prg_CC": 2,
      "post_condition_CC": 3,
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE111",
      "program-desc": "The program is given a string u containing one or more words separated by commas.\nThe words are all non-empty and consist of only letters. The program returns a\ndictionary D mapping every word x that occurs most frequently in u, to\nthe number of occurences of this x.\n\nExamples:\n    Pr_HE111('hi,world,hi,moon') =  {'hi':2 }\n    Pr_HE111('hi,world,hmm,world,hi') =  {'hi':2 , 'world':2 }\n",
      "program": "def Pr_HE111(u:str) -> dict[str,int] :\n    words = u.split(',')\n    ws = set(words)\n    wsmap = [ (w,len([x for x in words if x==w])) for w in ws ]\n    highest = 0\n    for (w,k) in wsmap:\n        if k>highest:\n            highest = k\n    highestMap = { w : highest for (w,k) in wsmap if k==highest }\n    return highestMap",
      "pre_condition": "The string u contains one or more words separated by commas.\nThe words are all non-empty and consist of only letters.",
      "pre_condition_incomplete": "def check_pre_HE111(u:str) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE111(u:str) -> bool:\n    words = u.split(',')\n    return all([w != [] and w.isalpha() for w in words])",
      "pre_condition_tests": "[\n    ['aa,bb'], ['aA'], [''], ['aA,a B'], [',b'],['a,'],['a:b'],\n    \"===\",\"===\",\n    ['ab,cd,EF,gH'],['foo@gmail'],[',,,'],['?,?']\n    ]",
      "post_condition": "Given a string u containing words separated by commas,\nthe dictionary D should map every word x that occurs most frequently in u, to\nthe number of occurences of this x.",
      "post_condition_incomplete": "def check_post_HE111(D:dict[str,int], u:str) -> bool:",
      "post_condition_solution": "def check_post_solution_HE111(D:dict[str,int], u:str) -> bool:\n    words = u.split(',')\n    ws = set(words)\n    wsmap = [ (w,len([x for x in words if x==w])) for w in ws ]\n    highest = max(freq for (w,freq) in wsmap)\n    return all(w in ws and D[w]==highest for w in D) and all(w in D for (w,freq) in wsmap if freq == highest)",
      "post_condition_tests": "[ [{'hi':2 }, 'hi,world,hi,moon'],\n        [ {'hi':2 , 'world':2 }, 'hi,world,hmm,world,hi'] ,\n        [ {'hi':1 }, 'hi'],\n        \"===\",\n        [ {'aa':2}, 'a,aa,bb,c,cc'], [ {'hi':2, 'moon':1 }, 'hi,world,hi,moon'],\n        \"===\",\n        [ {'a':1, 'aa':1, 'bb':1, 'c':1, 'cc':1} , 'a,aa,bb,c,cc'],\n        [ {'a':3 } , 'a,aa,aaa,aa,a,a'],\n        [ {'hi':2 , 'world':1 , 'moon':1} , 'hi,world,hi,moon'],\n        [ {'hi':2 }, 'hi,world,hmm,world,hi'],\n        [ {'hmm':1 }, 'hi,world,hmm,world,hi']\n        ]",
      "prg_CC": 8,
      "pre_condition_CC": 3,
      "post_condition_CC": 10,
      "pre_condition_complexity": "Q",
      "post_condition_complexity": "QQ"
   },
   {
      "task_id": "HE114",
      "program-desc": "Given a list s of numbers, the program returns the length of the\nlongest segment of s whose sum is negative. If there is no such\nsegment, None is returned.\n\nExamples:\n    Pr_HE114([1,-5,2,1,1]) =  4\n    Pr_HE114([0,0]) =  None\n",
      "program": "def Pr_HE114(s:list[float]) -> int :\n    N = len(s)\n    segs = []\n    for j in range(N):\n        for k in range(j+1,N+1):\n            z = s[j:k]\n            if sum(z) < 0 :\n                segs.append(len(z))\n    return None if segs==[] else max(segs)",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "Given a list s of numbers, r should be equal to the length of the\nlongest segment of s whose sum is negative. If there is no such\nsegment, r should be None.\n\nExamples:\n    check_post_HE114(4,[1,-5,2,1,1]) =  True\n    check_post_HE114(None,[0,0]) =  True\n",
      "post_condition_incomplete": "def check_post_HE114(r:int, s:list[float]) -> bool:",
      "post_condition_solution": "def check_post_solution_HE114(r:int, s:list[float]) -> bool:\n    N = len(s)\n    #zooo = [ z for z in [ s[j:k] for j in range(N) for k in range(j+1,N+1) ] if sum(z) < 0 ]\n    zegs = [ len(z) for z in [ s[j:k] for j in range(N) for k in range(j+1,N+1) ] if sum(z) < 0 ]\n    #print(f\">>> {zooo}\")\n    return r==None if zegs==[] else r==max(zegs)",
      "post_condition_tests": "[ [None,[]],\n        [4,[1,-5,2,1,1]],\n        [None,[0,0]],\n        [4,[1,-2,1,3,2,-4,1,1,1,1,1]],\n        \"===\",\n        [4,[4,-3,7,-3]], [1,[-1,-1]], [None,[2,-1,2]], [3,[0.001,0.001,0.001]],\n        \"===\",\n        [5,[1,0,0,-1,0,0,1]],\n        [3,[1,0,0,-1,2,-1,0,0,1]], [7,[1,0,0,-1,1,-1,0,0,1]],\n        [4,[1,0,0,-1,2,0,-1,0,0,1]],\n        [None, [0.001,0,0.001]],\n        [3, [0,0,0]], [2, [-1,0,2,-1,0,0,0]]\n        ]",
      "prg_CC": 5,
      "post_condition_CC": 6,
      "post_condition_complexity": "QQ"
   },
   {
      "task_id": "HE120",
      "program-desc": "Given non-empty a list A of numbers, the program returns a longest sorted segment of A,\nwhose length is at most k. k is at least one.\n\nExamples:\n    Pr_HE120([3,1,2,3,4],4) = [1,2,3,4]\n    Pr_HE120([3,1,2,3,4],2) = [1,2] ([2,3] is also ok)\n",
      "program": "def Pr_HE120(A:list[float], k:int) -> list[float] :\n    segments = []\n    for i in range(len(A)):\n        for v in range(i+1,len(A)+1):\n            z = A[i:v]\n            if z == sorted(z) :\n                segments.append(z)\n    longest = []\n    for z in segments:\n        if len(z) == k:\n            return z\n        if len(z) > len(longest) :\n            longest = z\n    return longest",
      "pre_condition": "A is a non-empty list and k is a number at least one.",
      "pre_condition_incomplete": "def check_pre_HE120(A:list[float], k:int) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE120(A:list[float], k:int) -> bool:\n    return A != [] and k > 0",
      "pre_condition_tests": "[\n    [[1],1], [[1,2], 5], [[],1], [[1,2], 0],\n    \"===\",\"===\",\n    [[1,2,3],-1], [[],0]\n    ]",
      "post_condition": "Given a non-empty list A of numbers, r should be equal to a longest sorted segment of A,\nwhose length is at most k.\n\nExamples:\n    check_post_HE120([1,2,3,4], [3,1,2,3,4], 4) = True\n    check_post_HE120([1,2], [3,1,2,3,4], 2) =  True",
      "post_condition_incomplete": "def check_post_HE120(r:list[float], A:list[float], k:int) -> bool :",
      "post_condition_solution": "def check_post_solution_HE120(r:list[float], A:list[float], k:int) -> bool :\n    print(f\">>> P120: {r}\")\n    if len(r) > k :\n        return False\n    segments = []\n    for i in range(len(A)):\n        for y in range(i+1,len(A)+1):\n            z = A[i:y]\n            if z == sorted(z) :\n                segments.append(z)\n    return r in segments  and len(r) == max([len(z) for z in segments if len(z) <= k])",
      "post_condition_tests": "[\n    [ [1,2,3,4], [3,1,2,3,4], 4] ,\n    [ [1,1], [3,1,1,3,4], 2 ] ,\n    [ [3], [3,1,2,3,4], 1 ] ,\n    [ [1,2,3], [3,1,2,0,1,2,3,0], 3 ] ,\n    [ [3], [3], 3 ] ,\n    \"===\",\n    [ [1,1,1], [1,1,1], 2 ] ,\n    [ [1,2,3,0], [1,2,3,0], 4 ] ,\n    \"===\",\n    [ [2,3], [3,1,2,3,4], 2 ] ,\n    [ [1,2,3], [3,1,2,3,0], 3 ] ,\n    [ [2,3], [3,4,2,3,0], 3 ] ,\n    [ [1,2,3], [3,1,2,3,4], 4] ,\n    [ [3,1,2,3], [3,1,2,3,4], 4] ,\n    [ [1,2,3,4], [3,1,2,3,4], 2 ] ,\n    [ [1,2], [3,1,2,3,4], 1 ] ,\n    [ [1,2], [3,1,2,0,1,2,3,0], 3 ]\n    ]",
      "prg_CC": 7,
      "pre_condition_CC": 2,
      "post_condition_CC": 8,
      "pre_condition_complexity": "S",
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE127",
      "program-desc": "The program is given a list s of integer pairs. Every pair (a,b) specifies\nan inclusive-interval of integers starting at a and ending at b. The program\nreturns a pair (x,y) which is the intersection of all the intervals in s.\nIf the intersection is empty, then None is returned.\n\nExamples:\n    Pr_HE127([(3,5),(0,4),(0,10)]) =  (3,4)\n    Pr_HE127([(3,5),(6,7)]) =  None\n",
      "program": "def Pr_HE127(s:list[tuple[int,int]]) -> tuple[int,int] :\n    if len(s)==0:\n        return None\n    x = s[0][0]\n    y = s[0][1]\n    for (a,b) in s:\n        x = max(x,a)\n        y = min(y,b)\n    return (x,y) if x<=y else None",
      "pre_condition": "For every pair (a,b) in s, a should be less or equal to b.",
      "pre_condition_incomplete": "def check_pre_HE127(s:list[tuple[int,int]]) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE127(s:list[tuple[int,int]]) -> bool:\n    return all([a<=b for (a,b) in s])",
      "pre_condition_tests": "[ [[]], [[(1,1),(2,3)]], [[(1,3),(2,1)]],\n                              \"===\",\"===\",\n                              [[(-1,2),(-2,3),(-3,4)]], [[(-1,-1),(-1,-2)]]\n                            ]",
      "post_condition": "Given a list s of integer pairs. Every pair (a,b) specifies\nan inclusive-interval of integers starting at a and ending at b.\nThe value of r should be a pair (x,y) which is the intersection of\nall the intervals in s.\nIf the intersection is empty, then r should be None.\n\nExamples:\n    check_post_HE127((3,4),[(3,5),(0,4),(0,10)]) = True\n    check_post_HE127(None,[(3,5),(6,7)]) = True\n",
      "post_condition_incomplete": "def check_post_HE127(r:tuple[int,int], s:list[tuple[int,int]]) -> bool:",
      "post_condition_solution": "def check_post_solution_HE127(r:tuple[int,int], s:list[tuple[int,int]]) -> bool:\n    if len(s)==0:\n        return r==None\n    a = max([a for (a,b) in s])\n    b = min([b for (a,b) in s])\n    return r==None if a>b else r==(a,b)",
      "post_condition_tests": "[ [None,[]], [(1,1),[(1,1),(1,1)]],\n                               [(3,4),[(3,5),(0,4),(0,10)]],\n                               [None,[(3,5),(6,7)]],\n                               [None,[(3,8),(6,9),(9,10)]],\n                             \"===\",\n                               [(0,10),[(3,5),(0,4),(0,10)]],\n                               [(6,8),[(3,8),(6,9),(9,10)]],\n                               [None,[(1,1),(1,2),(1,3)]],\n                             \"===\",\n                               [(0,0),[(-3,0),(-1,1),(0,2)]],\n                               [(-5,-2),[(-10,-1),(-11,-2),(-5,3)]],\n                               [ None, [(-5,5),(-5,0),(1,6)] ],\n                               [ None, [(-5,-5),(-5,0)] ],\n                               [ None, [(0,0),(0,0),(0,0)] ]\n                            ]",
      "prg_CC": 4,
      "pre_condition_CC": 2,
      "post_condition_CC": 5,
      "pre_condition_complexity": "Q",
      "post_condition_complexity": "Q"
   },
   {
      "task_id": "HE13",
      "program-desc": "Given a non-empty list s of positive integers, the program return the greatest common divisor of\nthe integers in s.\n\nExamples:\n    Pr_HE13([4,6,8]) =  3\n    Pr_HE13([4,6,9]) =  1\n    Pr_HE13([10,25,40]) =  5\n",
      "program": "def Pr_HE13(s:list[int]) -> int :\n    smallest_x = min(s)\n    if smallest_x <= 1:\n        return 1\n    greatest = 1\n    for d in range(1, smallest_x + 1):\n        if all([ x%d == 0 for x in s]):\n            greatest = d\n    return greatest",
      "pre_condition": "s is a non-empty list of positive integers.",
      "pre_condition_incomplete": "def check_pre_HE13(s:list[int]) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE13(s:list[int]) -> bool:\n    return s != [] and all([x>0 for x in s])",
      "pre_condition_tests": "[\n    [[1,2,3]], [[1,2,-3]], [[]], [[0]],\n    \"===\", \"===\",\n    [[2]], [[2,-1,-1]], [[1,2,3,4,5,0]]\n    ]",
      "post_condition": "The value r should be equal to the greatest common divisor of the integers in s.",
      "post_condition_incomplete": "def check_post_HE13(r:int, s:list[int]) -> bool:",
      "post_condition_solution": "def check_post_solution_HE13(r:int, s:list[int]) -> bool:\n    return r == max( d for d in range(1, min(s)+1) if all( x%d==0 for x in s))",
      "post_condition_tests": "[\n    [100, [100]],\n    [2, [4,6,8]],\n    [1, [4,6,9]],\n    [1, [2, 8, 1]],\n    [3, [6,9,27]],\n    \"===\",\n    [5, [5,25,12]],\n    [4, [16,8,24]],\n    \"===\",\n    [5, [10,25,40]],\n    [1, [1,25,5]],\n    [1, [4,6,8]],\n    [4, [4,6,8]],\n    [0, [4,8]],\n    [2, [4,8]]\n    ]",
      "prg_CC": 5,
      "pre_condition_CC": 3,
      "post_condition_CC": 4,
      "pre_condition_complexity": "Q",
      "post_condition_complexity": "QQ"
   },
   {
      "task_id": "HE132",
      "program-desc": "Given a string s that is assumed to contain only square brackets, the program\nreturns True if and only if the string contains a segment z made of properly closed\nbrackets that contains another segment z2 of properly closed brackets.\nA segment is properly closed if it starts with '[' and is ended with ']'.\n\nExamples:\n    Pr_HE132('[]') = False\n    Pr_HE132('[][]') = False\n    Pr_HE132('[[]]') = True\n    Pr_HE132('[[][]]') = True\n    Pr_HE132('[[]][') = True\n    Pr_HE132('[]]]][[[[]') = False\n",
      "program": "def Pr_HE132(s:str) -> bool:\n    #print(\">>> \" + s)\n    unclosedOpenBracket = 0\n    maxNestingDepth = 0\n    for c in s:\n        #print(f\"   stack={unclosedOpenBracket}, maxdepth={maxNestingDepth}, c={c}\")\n        if c=='[':\n            unclosedOpenBracket += 1\n            if unclosedOpenBracket > maxNestingDepth :\n                maxNestingDepth += 1\n        if c==']':\n            if unclosedOpenBracket > 0:\n                unclosedOpenBracket = unclosedOpenBracket - 1\n                if maxNestingDepth == unclosedOpenBracket + 2:\n                    return True\n\n    return False",
      "pre_condition": "The string s contains only square brackets.",
      "pre_condition_incomplete": "def check_pre_HE132(s:str) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE132(s:str) -> bool:\n    return all([c == '[' or c==']' for c in s ])",
      "pre_condition_tests": "[['[[[[['],[''],['[][]'],['[aaabcd]'],['[][][] '], [']'],\n                             \"===\",\"===\",\n                             [']['], ['()'],[']]'],['[  ]']\n                             ]",
      "post_condition": "Given a string s that is assumed to contain only square brackets, retval should\nbe equivalent to whether the string contains a segment z made of properly closed\nbrackets that contains another segment z2 of properly closed brackets.\nA segment is properly closed if it starts with '[' and is ended with ']'.\n\nExamples:\n    check_post_HE132(False, '[]') = True\n    check_post_HE132(False, '[][]') = True\n    check_post_HE132(True, '[[]]') = True\n    check_post_HE132(True, '[[][]]') = True\n    check_post_HE132(True, '[[]][') = True\n    check_post_HE132(False, '[]]]][[[[]') = True",
      "post_condition_incomplete": "def check_post_HE132(retval: bool, s : str) -> bool:",
      "post_condition_solution": "def check_post_solution_HE132(retval: bool, s : str) -> bool:\n    stack = 0 # keep track of how many '[' found so far which have not been closed\n    maxStackDepth = 0\n    expected = False\n    for c in s:\n        if c == ']' and stack==0:\n            continue\n        elif c == ']':\n            stack = stack-1\n            if maxStackDepth - stack == 2:\n                # found a segment with a nested brackets\n                expected = True\n                break\n        else :\n            # then c must me a '[', given the assumption that s contains only\n            # square brackets\n            stack = stack+1\n            if stack > maxStackDepth :\n                maxStackDepth = stack\n\n    return retval == expected",
      "post_condition_tests": "[  [True,'[[]]'],\n                                [True,'[[][]]'],\n                                [True,'[[]][['],\n                                [True,'[[[[[[[[[[]]'],\n                                [True,']][][]]][[][]]]]'],  [False,'[]][[[]'],\n                                \"===\",\n                                [False,']][[]]'], [False,'[[][]]'],\n                                \"===\",\n                                [True,']][[]][['],\n                                [True,'[[[[]]]]]]'],\n                                [True,'[][]]][[]]['],\n                                [False,'[][][[[]'],[False,'[[[[[][[][]'],\n                                [True,'[]]]]]]][[[[[]'],[True,'[][]'],[True,'[]'],[True,'[][[[[[[[[]']\n                             ]",
      "prg_CC": 7,
      "pre_condition_CC": 3,
      "post_condition_CC": 7,
      "pre_condition_complexity": "Q",
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE136",
      "program-desc": "Given a list s of integers, the program returns a pair (a,b) representing\na longest ascending segment in s that starts with a negative a and ends with\na positive b. If there is no such segment, None is returned.\n\nExamples:\n    Pr_HE136([2,-1,0,5,4]) = (-1,5)\n    Pr_HE136([-2,0]) = None\n",
      "program": "def Pr_HE136(s:list[int]) -> tuple[int,int]:\n    segment = []\n    longest = []\n    for x in s:\n       if segment==[]:\n           if x<0:\n               segment = [x]\n       elif segment[-1] <= x:\n           segment.append(x)\n       else: # end of the current monotonic segment\n           if segment[-1]>0 and len(segment) > len(longest):\n               longest = segment\n           if x<0:\n               segment = [x]\n           else:\n               segment = []\n    if len(segment) > len(longest) and segment[-1]>0 :\n        longest = segment\n\n    if len(longest)==0:\n        return None\n    return (longest[0],longest[-1])",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "Given a list s of numbers, r should be a pair (a,b) representing\na longest ascending segment in s that starts with a negative a and ends with\na positive b. If there is no such segment, r should be equal to None.\n\nExamples:\n    check_post_HE136((-1,5),[2,-1,0,5,4]) = True\n    check_post_HE136(None,[-2,0]) = True\n",
      "post_condition_incomplete": "def check_post_HE136(r:tuple[int,int], s:list[int]) -> bool:",
      "post_condition_solution": "def check_post_solution_HE136(r:tuple[int,int], s:list[int]) -> bool:\n    segs = []\n    N = len(s)\n    for j in range(N):\n        for k in range(j+1,N+1):\n            #print(f\"* {s[j:k]}\")\n            if s[j]<0 and s[k-1]>0 and all(a <= b for (a,b)in zip(s[j:k-1], s[j+1:k])):\n                segs.append(s[j:k])\n\n    if segs == [] :\n        return r == None\n    if r==None:\n        return False\n\n    longest = max(len(z) for z in segs)\n    (a,b) = r\n    #print(f\">>> {segs}\")\n    return any(z[0]==a and z[-1]==b and len(z)==longest for z in segs)",
      "post_condition_tests": "[ [None,[]], [None,[-1]],\n                               [(-1,5),[2,-1,0,5,4]], [None,[-2,0]], [None,[1,1]],\n                               [(-1,5),[-2,2,2,-1,0,5,4,-2,3,2]],\n                               [(-1, 5), [-2, 2, 2, -1, 0, 4, 5]],\n                                \"===\",\n                                [(-2,-1),[-2,-1]], [(-1,-5),[-1,-5]], [(-1,4),[2,-1,0,5,4]],[None,[-2,2]],\n                                \"===\",\n                                [None,[1,1,2]], [None,[-1,-1,-1]],\n                                [(-2,2),[0,-2,-1,-1,0,2,0]],\n                                [(-1,1),[-1,0,1,-4,-2,4,0]],\n                                [(-4,4),[-1,0,1,0,0,-4,-2,4,0]],\n                                [(-4,4),[-1,0,1,0,0,-4,-2,0,4,0]],\n                                [(-4,4),[-1,0,1,0,0,-4,-2,0,4,]],\n                                [(-1,1),[-1,0,1,0,0,-4,-2,0,4,]],\n                                [(-4,0),(-4,-2,0)], [(-4,0),(-4,-2,2,0)], [None,[-1,1]]\n                             ]",
      "prg_CC": 11,
      "post_condition_CC": 13,
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE138",
      "program-desc": "Given a list s of integers and an integer x, the program returns a sorted list t\nof four positive and even numbers from s whose sum is equal to x. If no such t\ncan be found, None is returned.\n\nExamples:\n    Pr_HE138([0,2,2,4,2,6],10) = [2,2,2,4]\n    Pr_HE138([2,2,2],6) = None\n",
      "program": "def Pr_HE138(s:list[int], x:int) -> list[int]:\n    if x < 8 or x%2 != 0:\n        return None\n    s = [a for a in s if a>0 and a%2==0 and a <= x-6]\n    N = len(s)\n    if N<4:\n        return None\n    for k1 in range(N-3):\n        for k2 in range(k1+1,N-2):\n            for k3 in range(k2+1,N-1):\n                for k4 in range(k3+1,N):\n                    t = [s[k1],s[k2],s[k3],s[k4]]\n                    if sum(t) == x:\n                        return sorted(t)\n    return None",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "Given a list s of integers and an integer x, t should be a sorted list containing\nfour positive and even numbers from s whose sum is equal to x. If no such four\nmembers of s can be found, t should be equal to None.\n\nExamples:\n    check_post_HE138([2,2,2,4],[0,2,2,4,2,6],10) = True\n    check_post_HE138(None,[2,2,2],6) = True\n",
      "post_condition_incomplete": "def check_post_HE138(t:list[int], s:list[int], x:int) -> bool:",
      "post_condition_solution": "def check_post_solution_HE138(t:list[int], s:list[int], x:int) -> bool:\n    s = [a for a in s if a>0 and a%2==0 and a<x ]\n    if x<8 or x%2==1 or len(s)<4 :\n        return t == None\n    N = len(s)\n    matches = [ sorted([s[k1], s[k2], s[k3], s[k4]])\n                   for k1 in range(N)\n                   for k2 in range(k1+1,N)\n                   for k3 in range(k2+1,N)\n                   for k4 in range (k3+1,N)\n                   if s[k1]+s[k2]+s[k3]+s[k4] == x\n                 ]\n    return t==None if matches==[] else t in matches",
      "post_condition_tests": "[ [None,[2,2,2,2,2],6],\n                               [None,[2,2,2],6],\n                               [[2,2,2,4],[0,2,2,4,4,2,6],10],\n                               [None,[0,2,-2,4,2,6],10],\n                               [None,[0,4,-2,4,2,2],10],\n                               [[2,2,4,4],[-2,4,2,2,1,1,4,2,6],12],\n                                \"===\",\n                                [None, [2,2,2,2],8],\n                                [[2,2,2,2],[0,2,2,4,2,6],8],\n                                [[0,2,2,6],[0,2,2,4,2,6],10],\n                                [[1,1,2,4],[1,1,4,2,2,2],8],\n                                [[4,2,2,2],[4,2,2,2],10],\n                                \"===\",\n                                [None,[],8], [None,[2,2],8], [None,[3,3,3,3],12],\n                                [None,[0,4,4,4],12], [None,[2,2,2,1],7],\n                                [None,[0,10,31,8,2,2],16],\n                                [[2,2,4,6], [-1,4,0,6,-2,2,3,1,2,8,2], 14],\n                                [[2,2,2,8], [-1,4,0,6,-2,2,3,1,2,8,2], 14],\n                                [None, [0,-2,2,2,0,2,10],16],\n                                [[2,2,6,6], [-1,4,0,6,-2,2,3,1,2,8,2], 16],\n                                [[-2,4,4,4],[1,4,4,-2,4,1],10],\n                                [[1,1,4,4],[1,4,4,-2,4,1],10]\n                             ]",
      "prg_CC": 13,
      "post_condition_CC": 14,
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE140",
      "program-desc": "The program replaces all non-alpha-num characters in s with a dash.\nHowever, when two or more such characters occur consecutively, they will be replaced\nby an underscore character instead of a dash. The program returns the resulting string.\n\nExamples:\n    Pr_HE140('a*b*c') = 'a-b-c'\n    Pr_HE140('a**2   c') = 'a_2_c'\n",
      "program": "def Pr_HE140(s:str) -> str :\n    t = ''\n    for c in s:\n        if c.isalnum():\n            t = t + c\n        else:\n            if t=='' :\n                t = t + '-'\n            elif t[-1].isalnum():\n                t = t + '-'\n            elif t[-1] == '-':\n                t = t[0:len(t)-1] + \"_\"\n    return t",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "r should be equal to a string t obtained by replacing all non-alpha-num\ncharacters in s with a dash. However, two or more such characters that occur consecutively\nshould be represented by an underscore character instead of a dash.",
      "post_condition_incomplete": "def check_post_HE140(r:str, s:str) -> bool :",
      "post_condition_solution": "def check_post_solution_HE140(r:str, s:str) -> bool :\n    if len(r) > len(s):\n        return False\n    k = 0\n    for x in r:\n        if x.isalnum():\n            if x != s[k]:\n                return False\n            k += 1\n        elif x == '-':\n            if s[k].isalnum() :\n                return False\n            k += 1\n        elif x == '_':\n            if s[k].isalnum() or k==len(s)-1 or s[k+1].isalnum():\n                return False\n            k += 1\n            while k < len(s) and not s[k].isalnum():\n                k += 1\n        else:\n            return False\n\n    return True\n\n# a sample of solution from gpt 3.5, the solution is almost correct,\n# with one line that can be fixed to a correct one, see below:\ndef xx_gpt35_check_post_solution_HE140(r:str, s:str) -> bool :\n    t = ''\n    consecutive = False\n    for char in s:\n        if char.isalnum():\n            t += char\n            consecutive = False\n        else:\n            if not consecutive:\n                t += '-'\n                consecutive = True\n            else:\n                t += '_'\n                # WP: the above logic from GPT is wrong. BUT, it can be fixed with this:\n                #t = t[0:len(t)-1] + \"_\"\n    return r == t",
      "post_condition_tests": "[\n      ['', ''],\n      ['9', '9'],\n      ['-', '+'],\n      ['_', '+* *+'],\n      ['a-b-c', 'a*b*c'],\n      ['a_2_c','a***2   c'],\n      \"===\",\n      ['a__c', 'a****c'], ['1-2', ' 1 2 '],\n      \"===\",\n      ['-1-2-', ' 1 2 '],\n      ['b_b', 'b____b'],\n      ['+', '+'],\n      ['a-2-c','a**2   c'],\n      ['a b c', 'a*b*c'],\n      ['a_b_c', 'a b c']\n    ]",
      "prg_CC": 6,
      "post_condition_CC": 13,
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE141",
      "program-desc": "The program is given a string containing file-names separated by commas.\nIt returns a list of valid file-names. A file-name is valid if it is\na string consisting of two parts separated by a comma.\nThe part before the comma can contain letters (lower or upper case), digits,\na dash or an underscore. It should start with a letter.\nThe part after the comma should be of length one, and at most three. It\nshould only contain letters (lower or upper case) or digits.\nDuplicates should be removed from the output list.\n\nExamples:\n    Pr_HE141(\"abc.txt,a12.mp3,a##.oo\") =  [\"abc.txt\",\"a12.mp3\"]\n    Pr_HE141(\"a_1.12,_a1.12\") =  [\"a_1.12\"]\n",
      "program": "def Pr_HE141(s:str) -> list[str] :\n    zs = s.split(',')\n    def validName(f):\n        parts = f.split('.')\n        if len(parts) != 2 :\n            return False\n        name = parts[0]\n        ext = parts[1]\n        return (len(name)>0 and 1<=len(ext)<=3 and name[0].isalpha()\n                and ext.isalnum()\n                and all([c.isalnum() or c=='-' or c=='_' for c in name]))\n    return [ y for y in { f for f in zs if validName(f)} ]",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "Given a string s containing file-names separated by commas, r should be\nequal to the list of valid file-names in s. A file-name is valid if it is\na string consisting of two parts separated by a comma.\nThe part before the comma can contain letters (lower or upper case), digits,\na dash or an underscore. It should start with a letter.\nThe part after the comma should be of length one, and at most three. It\nshould only contain letters (lower or upper case) or digits.\nThe list r should not contain duplicate file-names.\n\nExamples:\n    check_post_HE141([\"abc.txt\",\"a12.mp3\"],\"abc.txt,a12.mp3,a##.oo\") = True\n    check_post_HE141([\"a_1.12\"],\"a_1.12,_a1.12\") = True\n",
      "post_condition_incomplete": "def check_post_HE141(r:list[str], s:str) -> bool:",
      "post_condition_solution": "def check_post_solution_HE141(r:list[str], s:str) -> bool:\n    rz = { f for f in r }\n    if len(rz) != len(r):\n        return False\n\n    def validName(f):\n        parts = f.split('.')\n        if len(parts) != 2 :\n            return False\n        name = parts[0]\n        ext = parts[1]\n        return (len(name)>0 and 1<=len(ext)<=3 and name[0].isalpha()\n                and ext.isalnum()\n                and all([c.isalnum() or c=='-' or c=='_' for c in name]))\n\n    return rz == { f for f in s.split(',') if validName(f) }",
      "post_condition_tests": "[ [[],\"\"], [[],\",a,\"],\n                               [[\"abc.txt\",\"a12.mp3\"],\"abc.txt,a12.mp3,a##.oo\"],\n                               [[\"a_1.12\",\"a-1.12\"],\"a_1.12,_a1.12,a-1.12\"],\n                               [[],\"abc.txtx,abc.x-,2bc,txt,ab!.txt\"],\n                             \"===\",\n                               [[\"abc.abcd\"],\"abc.abcd,\"], [[\"abc.a_\",\"abc.a\"],\"abc.a_,abc.a\"],\n                               [[\"a.b\",\"a.b\",\"a.b\"],\"a.b,a.b,a.b\"],\n                             \"===\",\n                               [[\"a.b\"],\"a.b,a.b,a.b\"], [[\"p2.c\",\"p1.c\"],\"p1.c,p2.c\"],\n                               [[\"file1\",\"file2\",\"file3\"],\"file1,file2,file3\"],\n                               [[\"file1!.txt\"],\"file1!.txt\"],\n                               [[\"file2.t-t\"],\"file2.t-t\"],\n                               [[\"file3,html\"],\"file3.html\"],\n                               [[\"4file.htm\"],\"4file.htm\"]\n                            ]",
      "prg_CC": 4,
      "post_condition_CC": 5,
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE151",
      "program-desc": "Given a lits z of numbers, the program returns the sum of the cubic of all prime numbers in z. Elements\nwhich are not integers are ignored.\n\nExamples:\n    Pr_HE151([0, 1, 2]) = 8\n    Pr_HE151([2.2, 2, 1]) = 8\n    Pr_HE151([2, -1, 3, 4]) = 35\n",
      "program": "def Pr_HE151(z:list[float]) -> int :\n    def isPrime(x:int) -> bool:\n        for d in range(2, 1 + x//2):\n            if x % d == 0:\n                return False\n        return x >= 2\n\n    return sum([ x*x*x if int(x)==x and isPrime(x) else 0 for x in z])",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "r should be equal to the sum of the cubic of all prime numbers in z. Elements\nwhich are not integers are ignored.",
      "post_condition_incomplete": "def check_post_HE151(r:int, z:list[float]) -> bool :",
      "post_condition_solution": "def check_post_solution_HE151(r:int, z:list[float]) -> bool :\n    def isPrime(x:int) -> bool:\n        return x>1 and len([1 for d in range(2,x+1) if x % d == 0]) == 1\n\n    z = [ x for x in z if int(x)==x and isPrime(x) ]\n    return r == sum(x*x*x for x in z)",
      "post_condition_tests": "[\n     [0, []],\n     [0, [-1,0,1]],\n     [8, [-1,0,1,2]],\n     [35, [2, 2.0001, 3]],\n     [16, [2,-1,0,1,2]],\n     \"===\",\n     [2, [1,1]], [-35, [-2,-3]],\n     \"===\",\n     [35, [-1,0,1,2,4,6,3]],\n     [24, [1,2, 2.1, 2, -2, 2,0]],\n     [1, [1]],\n     [64, [0,0,4,0,0]],\n     [4, [0,0,2,0,0]],\n     [8, [2,0,2,0,2]],\n     [15.625, [2.5]]\n    ]",
      "prg_CC": 4,
      "post_condition_CC": 5,
      "post_condition_complexity": "QQ"
   },
   {
      "task_id": "HE158",
      "program-desc": "Given a list s of strings, the program returns a string with the longest\nstutter. A stutter of a string is a segment of length at least two,\nconsisting of the same letter.\nIf no string in s has a stutter, the program returns None.\n\nExamples:\n    Pr_HE158([\"hiii!\",\"woorld\"]) = \"hiii!\"\n    Pr_HE158([\"helo\",\"world\"]) = None\n",
      "program": "def Pr_HE158(s:list[str]) -> str :\n    def maxStutter(w) -> int :\n        stut = []\n        maxStutLen = 0\n        for c in w :\n            if stut==[] or c != stut[0]:\n                if stut != [] and stut[0].isalpha():\n                    maxStutLen = max(maxStutLen,len(stut))\n                stut = [c]\n            else:\n                stut.append(c)\n        maxStutLen = max(maxStutLen,len(stut))\n        #print(f\">>> {w}:{maxStutLen}\")\n        return maxStutLen\n\n    maxWord = \"\"\n    maxWordStutterLen = 0\n    for w in s:\n        longestStutLen = maxStutter(w)\n        #print(f\">>> {w}:{maxStutter(w)}, maxWord:{maxWord}\")\n        if longestStutLen>=2 and longestStutLen > maxWordStutterLen:\n            maxWord = w\n            maxWordStutterLen = longestStutLen\n    return maxWord if len(maxWord)>=2 else None",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "Given a list s of strings, the string r should be a member of s with the\nlongest stutter. A stutter of a string is a segment of length at least two,\nconsisting of the same letter.\nIf no string in s has a stutter, r should be equal to None.\n\nExamples:\n    check_post_HE158(\"hiii!\", [\"hiii!\",\"woorld\"])   = True\n    check_post_HE158(None, [\"helo\",\"world\"])  = True\n",
      "post_condition_incomplete": "def check_post_HE158(r:str, s:list[str]) -> bool :",
      "post_condition_solution": "def check_post_solution_HE158(r:str, s:list[str]) -> bool :\n\n    def maxStutLen(w) :\n        zs = []\n        stu = w[0]\n        w = w[1:]\n        for c in w :\n            if c==stu[0]:\n                stu = stu + c\n            else:\n               if stu[0].isalpha():\n                   zs.append(stu)\n               stu = c\n        zs.append(stu)\n        #print(f\">>> zs = {zs}\")\n        return max([len(stu) for stu in zs]) if zs != [] else 0\n\n    longestStuts = [ maxStutLen(w) for w in s if len(w)>= 2]\n    if longestStuts==[] or max(longestStuts)<2:\n        return r==None\n    else:\n        return r in s and len(r)>0 and maxStutLen(r)==max(longestStuts)\n",
      "post_condition_tests": "[\n     [None,[]], [None,[\"a\",\"a\",\"b\"]],\n     [\"hiii!\", [\"hiii!\",\"woorld\"]],\n     [None, [\"helo\",\"world\"]],\n     [\"hiii!\", [\"hiii!\",\"woorld\",\"hooo!\"]],\n     [\"ho!!!\", [\"hi!\",\"woorld\",\"ho!!!\"]],\n     [\"hooo!\", [\"hiii!\",\"woorld\",\"hooo!\"]],\n     \"===\",\n     [\"\",[]], [\"a\",[\"a\"]], [\"1223\",[\"1223\"]], [\"ooo\",[\"helooo\"]],\n     \"===\",\n     [\"xbbbx\",[\"xaax\",\"xaxaxaxa\",\"xbbbx\"]],\n     [\"xaax\",[\"xaax\",\"xaxaxaxa\",\"x***bx\"]],\n     [None,[\"11\",\"??\",\"**\"]],\n     [\"a**a\",[\"a**a\"]],\n     [\"aa\",[\"a**a\",\"a  a\"]],\n     [\"aa\",[\"a**a\",\"aba\"]],\n     [\"\",[\"***\",\"???\",\"\"]]\n    ]",
      "prg_CC": 5,
      "post_condition_CC": 7,
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE16",
      "program-desc": "Given a list s of strings, the program returns a list of integers,\nspecifying the number of distinct letters in each string in s.\nThe letters' case (lower case or upper case) is ignored.\n\nExamples:\n    Pr_HE16([\"Aaa\",\"hi! \"]) =  [1,2]\n",
      "program": "def Pr_HE16(s:list[str]) -> list[int] :\n    z = [ [c.lower() for c in w] for w in s]\n    return [ len({c for c in w if c.isalpha()}) for w in z]",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "Given a list s of strings, r should be a list of integers, specifying the number\nof distinct letters in each string in s.\nThe letters' case (lower case or upper case) is ignored.\n\nExamples:\n    check_post_HE16([1,2],[\"Aaa\",\"hi! \"]) =  True\n",
      "post_condition_incomplete": "def check_post_HE16(r:list[int], s:list[str]) -> bool:",
      "post_condition_solution": "def check_post_solution_HE16(r:list[int], s:list[str]) -> bool:\n    return len(r) == len(s) and all(n == len({c for c in w.lower() if c.isalpha()}) for (n,w) in zip(r,s))",
      "post_condition_tests": "[ [[],[]], [[0,0],[\"\",\"123\"]],\n    [[1,2],[\"Aaa\",\"hi! \"]], [[2,0,0],[\"AaxX12%$-+ \",\"***\",\"  \"]],\n    \"===\",\n    [[3],[\"123\"]], [[4],[\"ZzzbB\"]], [[],[\"!?\",\"*$@\"]],[[3],\"aaa\"],\n    \"===\",\n    [[3,3],[\"abcABC14@&\",\"ab  c\"]],[ [0,0,0], [\"\",\"  \",\"[]\"]],\n    [[2],[\"aa\",\"aa\"]], [[0],[\"!any\"]]\n    ]",
      "prg_CC": 6,
      "post_condition_CC": 5,
      "post_condition_complexity": "Q"
   },
   {
      "task_id": "HE160",
      "program-desc": "Given a non-empty list ops consisting of only characters '+' and '*',\nand a list of integers z, the program returns the integer value\nof the arithmentic expression represented by these\ntwo lists. For example, if ops = ['+','*'] and z=[1,2,3],\nthe represented expression is 1+2*3. Specific in this setup,\n+ has a higher priority than *. So the value of the previous\nexpression is 9 (and not 7).\n\nThe list z is assumed to contain n+1 integers, where n is\nthe number of elements in ops.\n\nExamples:\n    Pr_HE160(['+','*'],[1,2,3]) = 9\n    Pr_HE160(['+','*','+'],[1,2,3,2]) = 15\n",
      "program": "def Pr_HE160(ops:list[str], z:list[int]) -> int :\n    N = len(ops)\n    tot = None\n    plusTerm = None\n    for k in range(N):\n        if ops[k] == '+':\n            if plusTerm==None:\n                plusTerm = z[k]\n            else:\n                plusTerm += z[k]\n        else: # multiplication\n            if tot == None:\n                tot = 1\n            if plusTerm==None:\n                tot *= z[k]\n            else:\n                tot *= plusTerm + z[k]\n                plusTerm = None\n    if plusTerm == None:\n        tot *= z[N]\n    elif tot == None:\n        tot = plusTerm + z[N]\n    else:\n        tot *= plusTerm + z[N]\n\n    return tot",
      "pre_condition": "ops should be a non-empty list consisting of only characters '+' and '*'.\nThe list z should contain n+1 integers, where n is\nthe number of elements in ops.\n\nExamples:\n    check_pre_HE160(['+','*'],[1,2,3]) = True\n    check_pre_HE160(['+','*'],[1,2]) = False\n",
      "pre_condition_incomplete": "def check_pre_HE160(ops:list[str], z:list[int]) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE160(ops:list[str], z:list[int]) -> bool:\n    return len(ops)>0 and { o for o in ops}.issubset({ '+', '*'}) and len(z) == len(ops)+1",
      "pre_condition_tests": "[ [[],[]], [[],[1]],\n                           [['+','*'],[1,2,3]],  [['*','*'],[1,2,3]],\n                           [['+','+'],[1,2]], [['+','+'],[1,2,2,2]],\n                           [['+','-'],[1,2,3]],\n                           \"===\",\"===\",\n                           [['+','+'],[1,2,3]], [['+','+'],[1,-2,0]], [['*','+'],[1,-2,0]],\n                           [['+','-'],[1,1,1]], [['*','/'],[1,1,1]],\n                           [['*','*'],[0,0]], [['*','*'],[0,0,0,0]]\n                           ]",
      "post_condition": "Given a non-empty list ops consisting of only characters '+' and '*',\nand a list of integers z, v should be equal to the integer value\nof the arithmentic expression represented by these\ntwo lists. For example, if ops = ['+','*'] and z=[1,2,3],\nthe represented expression is 1+2*3. Specific in this setup,\n+ has a higher priority than *. So the value of the previous\nexpression is 9 (and not 7).\n\nExamples:\n    check_post_HE160(6, ['+','*'],[1,2,3]) = True\n    check_post_HE160(15, ['+','*','+'],[1,2,3,2])  = True\n",
      "post_condition_incomplete": "def check_post_HE160(v:int, ops:list[str], z:list[int]) -> bool :",
      "post_condition_solution": "def check_post_solution_HE160(v:int, ops:list[str], z:list[int]) -> bool :\n    expr = \"\"\n    N = len(ops)\n    plusTerm = False\n    for k in range(N):\n        if ops[k]=='+' and not plusTerm:\n            expr += \"(\"\n            plusTerm = True\n        expr += str(z[k])\n        if ops[k]=='*' and plusTerm:\n            expr += \")\"\n            plusTerm = False\n        expr += ' ' + ops[k] + ' '\n\n    expr += str(z[N])\n    if plusTerm:\n        expr += \")\"\n\n    try:\n       #print(f\">>> {expr}\")\n       val =  eval(expr)\n       #print(f\">>> {val}\")\n       return v == val\n    except:\n       return False\n",
      "post_condition_tests": "[\n     [6, ['+','+'],[1,2,3]], [24, ['*','*'],[2,3,4]],\n     [9, ['+','*'],[1,2,3]],\n     [15, ['+','*','+'],[1,2,3,2]],\n     [-3, ['+','*','+','+','*','+'],[1,0,1,1,1,0,-1]],\n     \"===\",\n     [0, ['*','+'],[1,0,1]],   [2, ['*','+','*'],[2,1,-1,2]],\n     \"===\",\n     [0, ['+'],[2,-2]], [-4, ['*'],[2,-2]],\n     [0, ['*','*','+'],[2,2,-2,2]], [-12, ['+','*','*'],[2,1,-2,2]],\n     [0, ['*','+','*'],[2,2,-2,2]],  [2, ['*','+','+'],[2,1,-2,2]],\n     [4, ['+','+','*'],[2,2,-2,2]], [-3, ['+','*','+'],[2,1,-2,1]],\n     [0, ['+','*'],[-2,0,2]], [0, ['*','+'],[-2,0,2]]\n    ]",
      "prg_CC": 8,
      "pre_condition_CC": 4,
      "post_condition_CC": 8,
      "pre_condition_complexity": "Q",
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE161",
      "program-desc": "Given a string zzz, the program returns a string r such that\nevery r[i] in r should be equal to zzz[i] with its case reversed (from upper case\nto lower case, and the other way around), if zzz[i] is a letter.\nElse, r[i] is the same as zzz[i].\nHowever, if no character in zzz is a letter, r should be equal to the reverse of zzz.\n\nExamples:\n  Pr_HE161(\"hi2hi!\") = \"HI2HI!\"\n  Pr_HE161(\"17\") = \"71\"\n",
      "program": "def Pr_HE161(zzz):\n    flg = 0\n    idx = 0\n    new_str = list(zzz)\n    for i in zzz:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    zzz = \"\"\n    for i in new_str:\n        zzz += i\n    if flg == 0:\n        return zzz[len(zzz)::-1]\n    return zzz",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "Every r[i] in r should be equal to zzz[i] with its case reversed (from upper case\nto lower case, and the other way around), if zzz[i] is a letter.\nElse, r[i] is the same as zzz[i].\nHowever, if no character in zzz is a letter, r should be equal to the reverse of zzz.\n\nExamples:\n  check_post_HE161(\"HI2HI!\", \"hi2hi!\") = True\n  check_post_HE161(\"71\", \"17\") = True",
      "post_condition_incomplete": "def check_post_HE161(r: str, zzz: str) -> bool:",
      "post_condition_solution": "def check_post_solution_HE161(r: str, zzz: str) -> bool:\n  if all([ not c.isalpha() for c in zzz]):\n      return r == zzz[::-1]\n  if len(r) != len(zzz):\n      return False\n  return all([ (r == x.swapcase()) if x.isalpha() else (r==x) for (r,x) in zip(r,zzz) ])",
      "post_condition_tests": "[\n            [\"T3ST\",\"t3st\"],[\"1234\",\"4321\"],[\"AB\",\"ab\"],[\"#A@C\",\"#a@c\"],[\"tesT\",\"TESt\"],[\"\",\"\"],\n            \"===\",\n            [\"o321\",\"123o\"],[\"p-o-n-g>\", \"p-o-N-G>\"],[\"a\",\"ABC\"],\n            \"===\",\n            [\"!321\",\"123!\"],\n            [\"TEStEST\",\"tesTest\"],[\"test\",\"test\"],[\"te\",\"TEST\"]]",
      "prg_CC": 5,
      "post_condition_CC": 6,
      "post_condition_complexity": "QQ"
   },
   {
      "task_id": "HE20",
      "program-desc": "The program is given two non-empty lists of numbers, s and t. It returns a pair\n(x,y) of an element in s and an element in t such that the difference between\ntheir squared values is the smallest.\n\nExamples:\n    Pr_HE20([1,10],[4,5]) =  (1,4)\n    Pr_HE20([-1,3],[0,1]) =  (-1,0)\n    Pr_HE20([1],[5,6,7,-2]) = (1,-2)\n",
      "program": "def Pr_HE20(s:list[float], t:list[float]) -> tuple[float,float] :\n    minDist = None\n    chosen = None\n    for x in s:\n         for y in t:\n              m = abs(x*x - y*y)\n              if minDist==None or m < minDist:\n                   minDist = m\n                   chosen = (x,y)\n    return chosen",
      "pre_condition": "s and t are both non-empty.",
      "pre_condition_incomplete": "def check_pre_HE20(s:list[float], t:list[float]) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE20(s:list[float], t:list[float]) -> bool:\n    return len(s)>0 and len(t) > 0",
      "pre_condition_tests": "[[[1],[1,2,3]], [[1,2,3],[1]], [[],[]],\n                           \"===\",\"===\",\n                             [[12,3],[12]], [[12],[]], [[],[3]]\n                           ]",
      "post_condition": "Given two non-empty lists of numbers, s and t, z should be a pair\n(x,y) of an element in s and an element in t such that the difference\nbetween their squared values is the smallest.\n\nExamples:\n    check_post_HE20((1,4),[1,10],[4,5]) = True\n    check_post_HE20((-1,0),[-1,3],[0,1]) = True\n    check_post_HE20((1,-2),[1],[5,6,7,-2]) =  True\n",
      "post_condition_incomplete": "def check_post_HE20(z:tuple[float,float], s:list[float], t:list[float]) -> bool:",
      "post_condition_solution": "def check_post_solution_HE20(z:tuple[float,float], s:list[float], t:list[float]) -> bool:\n    u = sorted([ (abs(x*x - y*y),x,y) for x in s for y in t])\n    (m,x,y) = u[0]\n    (x1,y1) = z\n    return abs(x1*x1 - y1*y1) == m",
      "post_condition_tests": "[ [(1,4),[1,10],[4,5]], [(1,-2),[1],[5,6,7,-2]],\n                              [(1,1),[1,1,0,0],[0,0,1,1]], [(0,0),[1,1,0,0],[0,0,1,1]],\n                              [(-1,1),[1,-1],[0,1,2]],\n                             \"===\",\n                             [(10,12),[10,12],[12,13]],\n                             [(12,13),[10,12],[-12,13]],\n                             [(1,-3),[1,2,3],[-3]],\n                             \"===\",\n                             [(-1,1),[-1,-3],[0,1,3]],\n                             [(-3,3),[-1,-3],[0,1,3]],\n                             [(4,4),[1,2,3,4],[4]], [(4,4),[4],[1,2,3,4]],\n                             [(3,4),[1,2,3,-4],[4]],\n                             [(4,3),[4],[1,2,3,-4]]\n                            ]",
      "prg_CC": 5,
      "pre_condition_CC": 2,
      "post_condition_CC": 3,
      "pre_condition_complexity": "S",
      "post_condition_complexity": "QQ"
   },
   {
      "task_id": "HE21",
      "program-desc": "The program is given a list s containing measurement data. The program returns\nthe scaled integer average of the measurements in s. A measurement value is either\na number or None.\nTo obtain the scaled average, the measurements in s are first linearly rescaled to\nvalues between 0 and 100, with 0 corresponds to the lowest value in s and 100 to\nthe highest value in s. The integer average is obtained by taking the average\nover the rescaled measurements, and then rounding down the result to the\nnearest integer.\n\nNone measurements are ignored. If s contains less than two distinct numeric\nmeasurements, the average is considered to be None.\n\nExamples:\n    Pr_HE21([1,1,None]) = None\n    Pr_HE21([1,2,3]) = 50\n    Pr_HE21([1,2,4]) = 44\n",
      "program": "def Pr_HE21(s:list[float]) -> int :\n    s = [x for x in s if x != None]\n    zz = { x for x in s}\n    if len(zz) < 2:\n        return None\n    minval = min(s)\n    maxval = max(s)\n    scaling = 100 / (maxval - minval)\n    import math\n    avrg = sum([scaling * (x - minval) for x in s])/len(s)\n    return math.floor(avrg)\n",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "Given a list s containing measurement data, the value of avrg should be equal to the\nscaled integer average of the measurements in s. A measurement value is either\na number or None.\nTo obtain the scaled average, the measurements in s are first linearly rescaled\nto values between 0 and 100, with 0 corresponds to the lowest value in s and 100\nto the highest value in s. The integer average is obtained by taking the average\nover the rescaled measurements, and then rounding down the result to the nearest\ninteger.\n\nNone measurements are ignored. If s contains less than two distinct numeric\nmeasurements, the average is considered to be None.\n\nExamples:\n    check_post_HE21(None,[1,1,None]) = True\n    check_post_HE21(50, [1,2,3]) = True\n    check_post_HE21(44, [1,2,4]) = True\n",
      "post_condition_incomplete": "def check_post_HE21(avrg:int, s:list[float]) -> bool:",
      "post_condition_solution": "def check_post_solution_HE21(avrg:int, s:list[float]) -> bool:\n    s = [x for x in s if x != None]\n    if len(s) < 2 :\n        return avrg==None\n    xmin = min(s)\n    xmax = max(s)\n    if xmin==xmax:\n        return avrg==None\n    import statistics\n    import math\n    return avrg == math.floor(statistics.mean([ (100/(xmax-xmin))*(x - xmin) for x in s]))",
      "post_condition_tests": "[ [None,[]], [None,[1,1,None,1]],\n                             [50,[1,1,None,2,2]], [50,[50,100]], [20,[7,7,7,7,None,8]],\n                             [50, [1,2,3]], [44, [1,2,4]],\n                             \"===\",\n                             [0.5, [0,1]], [75,[50,100]], [0,[0,None,0]], [44,[3,6,13]],\n                             \"===\",\n                             [None,[100]], [None,[100,100]], [None,[None,None]],\n                             [50,[0,100]], [50,[1,100]], [50,[99,100]],\n                             [50,[1,2,3,None,4,5]],  [50,[7,10,None,13,16,19]],\n                             [53, [7,10,10,12.5,12,17,17]],\n                             [None,[None,None,None,0,1]]\n\n                            ]",
      "prg_CC": 6,
      "post_condition_CC": 6,
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE24",
      "program-desc": "For a given a positive integer n bigger than one, the program returns the largest integer between 1 and n/2 (inclusive) that divides n+1.\n\nExamples:\n   Pr_HE24(24) = 5\n",
      "program": "def Pr_HE24(n:int) -> int:\n   for i in reversed(range(1, 1 + int(n/2))):\n        if (n+1) % i == 0:\n            return i",
      "pre_condition": "n is an integer bigger than one.",
      "pre_condition_incomplete": "def check_pre_HE24(n:int) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE24(n:int) -> bool:\n    return n > 1",
      "pre_condition_tests": "[[2],[99],[1],[-99],\n                            \"===\",\"===\",\n                            [3], [1001], [-1], [0]\n                            ]",
      "post_condition": "retval is the largest integer between 1 and n/2 (inclusive) that divides n+1.\n\nExamples:\n   check_post_HE24(5,24) = True",
      "post_condition_incomplete": "def check_post_HE24(retval:int, n:int) -> bool:",
      "post_condition_solution": "def check_post_solution_HE24(retval:int, n:int) -> bool:\n    return retval == max([ x for x in range(1, 1 + int(n/2)) if (n+1) % x == 0])",
      "post_condition_tests": "[ [1,2],[5,14],[7,48],[8,31],[1,6],\n                             \"===\",\n                             [2,2], [1,31],\n                             \"===\",\n                             [1,30], [25,99], [7,20],\n                             [2,32],[16,31],[0,3],[6,5] ]",
      "prg_CC": 3,
      "pre_condition_CC": 1,
      "post_condition_CC": 2,
      "pre_condition_complexity": "S",
      "post_condition_complexity": "Q"
   },
   {
      "task_id": "HE30",
      "program-desc": "Given a list s of numbers, the program returns the set of numbers in s which are positive,\nand have positive neighbours (the numbers before and after it in s).\n\nExamples:\n    Pr_HE30([4,6,9]) =  {6}\n    Pr_HE30([1,0,1,2,3,4,0,5]) =  {2,3}\n",
      "program": "def Pr_HE30(s:list[float]) -> set[float] :\n    if len(s) < 3 :\n        return set()\n    r = set()\n    prev = s[0]\n    x = s[1]\n    for next in s[2:]:\n        if x>0 and prev>0 and next>0:\n            r.add(x)\n        prev = x\n        x = next\n    return r",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "Given a list s of numbers, r should be equal to the set of the numbers in s which are positive,\nand have positive neighbours (the numbers before and after it in s).\n\nExamples:\n    check_post_HE30({6},[4,6,9])   = True\n    check_post_HE30({2,3},[1,0,1,2,3,4,0,5])  = True\n",
      "post_condition_incomplete": "def check_post_HE30(r:list[float], s:list[float]) -> bool:",
      "post_condition_solution": "def check_post_solution_HE30(r:list[float], s:list[float]) -> bool:\n   return r == { b for (a,b,c) in zip(s,s[1:],s[2:]) if a>0 and b>0 and c>0 }",
      "post_condition_tests": "[\n    [set(),[]], [set(),[2,2]],\n    [{6},[4,6,9]], [{2,3},[1,0,1,2,3,4,0,5]],\n    [{2,5},[1,0,1,2,3,0,2,2,2,0,8,5,6]],\n    [set(),[1,2,0,3,3,0,4]],\n    \"===\",\n    [{1,2,3},[1,2,3]],\n    [{0,2},[1,0,2,0,3]],\n    [{0},[-1,0,0,0,-1]],\n    \"===\",\n    [set(),[-1,-2,0,-3]],\n    [{2,3,4},[1,2,3,4,5]],\n    [set(),[1,2,0,3,4,0,5]],\n    [{2},[3,2]],\n    [set(),[0,0,0]]\n    ]",
      "prg_CC": 6,
      "post_condition_CC": 5,
      "post_condition_complexity": "Q"
   },
   {
      "task_id": "HE37",
      "program-desc": "This program takes a list of numbers s and returns a list t such that every t[i]\nis the same as s[i], for even i. The elements of t at the odd indicies are equal to\nthe elements of the odd indicies of s, but sorted.\n\nExamples:\n    Pr_HE37([0,3,0,1]) = [0,1,0,3]\n    Pr_HE37([3,3,4,1]) = [3,1,4,3]\n",
      "program": "def Pr_HE37(s:list[float]) -> list[float] :\n    evens = s[::2]\n    odds = s[1::2]\n    odds.sort()\n    t = []\n    for k in range(len(odds)):\n        t.append(evens[k])\n        t.append(odds[k])\n    if len(evens) > len(odds):\n        t.append(evens[-1])\n    return t",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "Every t[i] of the list t should be the same as s[i], for even i. However, the elements of t at\nthe odd indicies should be equal to the elements of the odd indicies of s, but sorted.\n\nExamples:\n    check_post_HE37([0,1,0,3],[0,3,0,1]) = True\n    check_post_HE37([3,1,4,3],[3,3,4,1]) = True\n",
      "post_condition_incomplete": "def check_post_HE37(t:list[float], s:list[float]) -> bool:",
      "post_condition_solution": "def check_post_solution_HE37(t:list[float], s:list[float]) -> bool:\n    evens = s[::2]\n    odds  = s[1::2]\n    odds.sort()\n    evens_t = t[::2]\n    odds_t  = t[1::2]\n    return evens == evens_t and odds == odds_t",
      "post_condition_tests": "[ [[],[]],\n                             [[0],[0]],\n                             [[1,3,0],[1,3,0]],\n                             [[0,1,0,3], [0,3,0,1]],\n                             [[3,1,4,3], [3,3,4,1]],\n                             \"===\",\n                             [[0,0,1,3], [0,3,0,1]],\n                             [[3,2,1,0], [3,2,1,0]],\n                             \"===\",\n                             [[2,1],[2,1]],\n                             [[1,2,3,4],[1,2,3,4]],\n                             [[1,1,3,2,0,4],[1,4,3,1,0,2]],\n                             [[],[0]],\n                             [[0,3,1],[1,3,0]],\n                             [[0],[0,0,0]],\n                             [[0,3,0,1], [0,3,0,1]]\n                            ]",
      "prg_CC": 3,
      "post_condition_CC": 2,
      "post_condition_complexity": "S"
   },
   {
      "task_id": "HE42",
      "program-desc": "Given a list s of integers and k, the program returns a longest segment of\ns that can be turned into a flat segment by decreasing every positive element with k,\nand increasing negative elements with k.\nA flat segment is a segment of a list whose elements are all the same.\n\nExamples:\n    Pr_HE42([1,2,0,-2,0],2) = [2,0,-2,0]\n    Pr_HE42([0,1,-1],1) = [0,1,-1]\n",
      "program": "def Pr_HE42(s : list[int], k:int) -> list[int] :\n\n    if len(s) <= 1: return s\n\n    def transform(x):\n        if x>0:\n            return x-k\n        elif x<0 :\n            return x+k\n        else:\n            return x\n\n    st = [ transform(x) for x in s]\n    N = len(s)\n    longest = [s[0]]\n    for j in range(N):\n        for k in range(j+2,N+1):\n            seg2 = st[j:k]\n            x0 = seg2[0]\n            if all(x==x0 for x in seg2) and len(seg2) > len(longest):\n                longest = s[j:k]\n    return longest",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "Given a list s of integers and k. r should be equal to a longest segment of\ns that can be turned into a flat segment by decreasing every positive element with k,\nand increasing negative elements with k.\nA flat segment is a segment of a list whose elements are all the same.\n\nExamples:\n    check_post_HE42([2,0,-2,0], [1,2,0,-2,0], 2) = True\n    check_post_HE42([0,1,-1], [0,1,-1], 1) = True\n",
      "post_condition_incomplete": "def check_post_HE42(r:list[int], s : list[int], k:int) -> bool :",
      "post_condition_solution": "def check_post_solution_HE42(r:list[int], s : list[int], k:int) -> bool :\n    if len(s)<=1:\n        return r==s\n    if r==[]:\n        return False\n\n    def flat(z):\n        return all(x == z[0] for x in z)\n    def trans(z):\n        return [ x-k if x>0 else (x+k if x<0 else x) for x in z ]\n\n    if not flat(trans(r)):\n        return False\n\n    N = len(s)\n    segs = [zg for zg in [ s[j:k] for j in range(N) for k in range(j+1,N+1)] if flat(trans(zg)) ]\n    return len(r) == max(len(sg) for sg in segs) and r in segs",
      "post_condition_tests": "[\n    [[],[],0], [[0],[0],3],\n    [[0,0,0],[2,0,0,0],1], [[4],[0,2,3,4],1],\n    [[2,0,-2,0], [1,2,0,-2,0], 2], [[0,1,-1], [0,1,-1], 1],\n    \"===\",\n    [[0],[0,-1],1], [[0,0],[0,5],5], [[0],[0,1,-1],1], [[0],[0,1],1],\n    \"===\",\n    [[1],[1,2,3],1], [[2],[1,2,3],1], [[3],[1,2,3],1],\n    [[2,2,2],[1,2,2,2,3,3],0],  [[0,2,2,-2,-2],[1,0,2,2,-2,-2],2],\n    [[],[1,2,3],1], [[0],[0,-1,3],1]\n    ]",
      "prg_CC": 8,
      "post_condition_CC": 10,
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE43",
      "program-desc": "The program checks whether s contains three distinct elements whose sum is three.\n\nExamples:\n    Pr_HE43([1,2,0]) = True\n    Pr_HE43([0,2,3,-2]) = True\n    Pr_HE43([1,2,3]) = False\n",
      "program": "def Pr_HE43(s : list[int]) -> bool :\n    for x in s:\n        for y in s:\n            for z in s:\n                if x!=y and y!=z and x!=z and x+y+z==3:\n                    return True\n    return False",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "r should be equivalent to whether s contains three distinct elements whose sum is three.\n\nExamples:\n    check_post_HE43( True , [1,2,0]) = True\n    check_post_HE43( True , [0,2,3,-2]) = True\n    check_post_HE43( False, [1,2,3]) = True",
      "post_condition_incomplete": "def check_post_HE43(r:bool , s:list[int]) -> bool :",
      "post_condition_solution": "def check_post_solution_HE43(r:bool , s:list[int]) -> bool :\n    v = [1 for x in s for y in s for z in s if x!=y and x!=z and y!=z and x+y+z==3 ]\n    return r == (v != [])",
      "post_condition_tests": "[\n    [False, []],\n    [True, [1,2,0]],\n    [True, [0,2,3,-2]],\n    [False, [0,3,0]],\n    \"===\",\n    [True,[3,3,3]],\n    [False,[1,9,-10,0,4,1]],\n    \"===\",\n    [True, [0,0]],\n    [True, [-1,0,0,-2,1,6]],\n    [False, [0,1,0,-2,4]],\n    [True, [0]],\n    [False, [3,-2,0,-1,2]]\n    ]",
      "prg_CC": 8,
      "post_condition_CC": 8,
      "post_condition_complexity": "QQ"
   },
   {
      "task_id": "HE45",
      "program-desc": "Given the length b of a side of a scalene triangle, and h as the triangle's height\nperpendicular to b, the program returns a value Z, equals to the area of two of\nsuch triangles.\n\nBoth b and h are assumed to be positive.\n\nExamples:\n    Pr_HE45(4,2) = 8\n",
      "program": "def Pr_HE45(b: float, h: float) -> float:\n  triangleArea = 0.5 * b * h\n  return 2 * triangleArea",
      "pre_condition": "Both a,h are positive.",
      "pre_condition_incomplete": "def check_pre_HE45(b: float, h: float) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE45(b: float, h: float) -> bool:\n    return b>0 and h>0",
      "pre_condition_tests": "[[5,5],[0.0001,9999.9],[0,1000],[1,-0.0001],\"===\",\"===\",[2,9],[9,2],[-1,9],[9,-1],[0,0] ]",
      "post_condition": "Given the length b of a side of a scalene triangle, and h as the triangle's height\nperpendicular to b, retval should be equal to the area of two of such triangles.",
      "post_condition_incomplete": "def check_post_HE45(retval: float, b: float, h: float) -> bool:",
      "post_condition_solution": "def check_post_solution_HE45(retval: float, b: float, h: float) -> bool:\n    return retval == b*h",
      "post_condition_tests": "[[15,5,3],[22,2,11],[2,2,1],\n                             \"===\",\n                             [1,2,1], [4,2,1],\n                             \"===\",\n                             [15,3,5],[100,1,100],\n                             [24.5,7,7],[1,12,3]]",
      "prg_CC": 1,
      "pre_condition_CC": 2,
      "post_condition_CC": 1,
      "pre_condition_complexity": "S",
      "post_condition_complexity": "S"
   },
   {
      "task_id": "HE50",
      "program-desc": "Given a string s, the program returns an encoded version of s. This is\nobtained by shifting every character c in s.\nA letter is cyclicly shifted by k symbols in the alphabet. We keep the case (e.g.\nif it was lower case, it remains lower case). Digits in a number are shifted\nk symbols in 0..9.\nNon alpha-numneric characters, except spaces, are left unchanged.\nSegments consisting of only spaces are replaced by a single dash.\n\nExamples:\n    Pr_HE50(\"h3i!\",1) = \"i4j!\"\n    Pr_HE50(\"Hi  2\",26) = \"Hi-8\"\n",
      "program": "def Pr_HE50(s:str, k:int) -> str:\n  def shiftgeneral(c,baseChar,cyclicity,k):\n     base = ord(baseChar)\n     d = chr(base + ((ord(c) - base + k) % cyclicity))\n     return d\n\n  def shift(c,k):\n      if c.isalpha() and c.islower():\n          return shiftgeneral(c,'a',26,k)\n      elif c.isalpha() and c.isupper():\n          return shiftgeneral(c,'A',26,k)\n      elif c.isdigit():\n          return shiftgeneral(c,'0',10,k)\n      else:\n          return c\n  import re\n  z = \"\".join([ shift(c,k) for c in s])\n  return re.sub(' +','-',z)",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "The string r should be equal to the encoded version of s. This is\nobtained by shifting every character c in s.\nA letter is cyclicly shifted by k symbols in the alphabet. We keep the case (e.g.\nif it was lower case, it remains lower case). Digits in a number are shifted\nk symbols in 0..9.\nNon alpha-numneric characters, except spaces, are left unchanged.\nSegments consisting of only spaces are replaced by a single dash.\n\nExamples:\n    check_post_HE50(\"i4j!\",\"h3i!\",1) = True\n    check_post_HE50(\"Hi-8\",\"Hi  2\",26) = True",
      "post_condition_incomplete": "def check_post_HE50(r:str, s:str, k:int) -> bool:",
      "post_condition_solution": "def check_post_solution_HE50(r:str, s:str, k:int) -> bool:\n    def ok(c,d):\n       if c.isalpha() and c.islower():\n           return (ord(c) - ord('a') + k) % 26 == ord(d) - ord('a')\n       if c.isalpha() and c.isupper():\n           return (ord(c) - ord('A') + k) % 26 == ord(d) - ord('A')\n       if c.isdigit():\n           return (ord(c) - ord('0') + k) % 10 == ord(d) - ord('0')\n       return c==d\n\n    import re\n    s = re.sub(' +','-',s)\n    return len(r) == len(s) and all([ok(c,d) for (c,d) in zip(s,r)])",
      "post_condition_tests": "[[\"\",\"\",3],\n                             [\"abc-123\",\"abc 123\",0],\n                             [\"-c-C-\",\" a   A \",2],\n                             [\"i4j!\",\"h3i!\",1], [\"Hi-8\",\"Hi  2\",26], [\"Olssv--890-:K\",\"Hello -123 :D\",7],\n                             \"===\",\n                             [\"p3\",\"o2!\",1], [\"ij\",\"HI\",1], [\"[\",\"Z\",1], [\"[\",\"A\",27],[\"<\",\"2\",10],[\" b\",\" a\",1],[\"--b\",\"  a\",1],\n                             \"===\",\n                             [\"$-j0k1\", \"$ a1b2\",9], [\"?!$%\",\"?!$%\",3], [\"-001\",\"-990\",1], [\"-b-C--0-\",\" a  B   -9 \",1],\n                             [\"-w-x---y-\",\" u v   w \",2],\n                             [\"y+z\", \"x + y\",1], [\"pl\",\"OK\",1], [\" 0    10 \", \" 0    10 \",0]\n                             ]",
      "prg_CC": 2,
      "post_condition_CC": 3,
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE57",
      "program-desc": "The program returns true if and only if the elements in the list t are ordered\nmonotonically, either increasing or decreasing. t is obtained from s by\nmultiplying every element of s with -1.\n\nExamples:\n    Pr_HE57([1, 2, 4, 20])  = True\n    Pr_HE57([1, 20, 4, 10]) = False\n    Pr_HE57([4, 1, 0, -10]) = True\n",
      "program": "def Pr_HE57(s: list) -> bool :\n    if s == sorted(s) or s == sorted(s, reverse=True):\n        return True\n    return False",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "retval should be equivalent to whether the elements in the list t are ordered monotonically,\neither increasing or decreasing. t is obtained from s by multiplying every element\nof s with -1.\n\nExamples:\n    check_post_HE57(True, [1, 2, 4, 20])   = True\n    check_post_HE57(False, [1, 20, 4, 10]) = True\n    check_post_HE57(True, [4, 1, 0, -10])  = True\n",
      "post_condition_incomplete": "def check_post_HE57(retval:bool, s:list) -> bool:",
      "post_condition_solution": "def check_post_solution_HE57(retval:bool, s:list) -> bool:\n    if s == sorted(s) or s == sorted(s, reverse=True):\n        expected = True\n    else :\n        expected = False\n    return retval == expected",
      "post_condition_tests": "[ [True, [1, 2, 4, 10]],\n                             [False, [1, 20, 4, 10]],\n                             [True, [4, 1, 0, -10]],\n                             [True, [9, 9, 9, 9]],\n                             [True, []],\n                             [True, [-1]],\n                             \"===\",\n                             [False, []],\n                             [False, [0, 0]],\n                             [False, [-3, 1]],\n                             \"===\",\n                             [True, [3,0,-3,-3]],\n                             [True, [3,0,-3]],\n                             [False, [4, 1, 0, -10]],\n                             [True, [4, 1, 2, -10]],\n                             [False, [1,1]]\n                            ]",
      "prg_CC": 3,
      "post_condition_CC": 3,
      "post_condition_complexity": "S"
   },
   {
      "task_id": "HE60",
      "program-desc": "The program returns the sum of integers 1 to x (exclusive), multiplied by two.\nThe parameter x is assumed to be positive integer.\n\nExamples:\n    Pr_HE60(1) = 0\n    Pr_HE60(4) = 12\n",
      "program": "def Pr_HE60(x:int) -> int :\n    z = 0\n    k = 1\n    while k < x:\n        z += 2*k\n        k += 1\n    return z",
      "pre_condition": "x is positive.",
      "pre_condition_incomplete": "def check_pre_HE60(x:int) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE60(x:int) -> bool:\n   return x>0",
      "pre_condition_tests": "[ [1], [99], [0], [-1], \"===\", \"===\", [9999], [-9999] ]",
      "post_condition": "y should be equal to the sum of integers 1 to x (exclusive), multiplied by two.",
      "post_condition_incomplete": "def check_post_HE60(y:int, x:int) -> bool:",
      "post_condition_solution": "def check_post_solution_HE60(y:int, x:int) -> bool:\n    return y == 2* sum(range(0,x))",
      "post_condition_tests": "[ [0,1], [2,2], [6,3], [12,4],\n                             \"===\",\n                             [1,1], [6,4],\n                             \"===\",\n                             [20,5], [0,-2],\n                             [1,1], [1,2], [6,4], [20,4]\n                            ]",
      "prg_CC": 2,
      "pre_condition_CC": 1,
      "post_condition_CC": 1,
      "pre_condition_complexity": "S",
      "post_condition_complexity": "Q"
   },
   {
      "task_id": "HE65",
      "program-desc": "Given two non-negative integers x and k, the program returns an integer y\nobtained by shifting the digits in x by k positions circularly towards\nthe left, if k is odd. And otherwise by k positions circularly towards\nthe right, if k is even.\nAny leading zero's in y are removed.\n\nExamples:\n    Pr_HE65(123456,1) = 234561\n    Pr_HE65(123456,3) = 456123\n    Pr_HE65(123456,2) = 561234\n",
      "program": "def Pr_HE65(x:int, k:int) -> int :\n    xx = str(x)\n    if len(xx) <= 1:\n        return x\n\n    def shiftLeft(z,k):\n        while k>0:\n            z = z[1:] + z[0]\n            k = k-1\n        return z\n    def shiftRight(z,k):\n        N = len(z)\n        while k>0:\n            z = z[N-1] + z[0:N-1]\n            k = k-1\n        return z\n\n    return int(shiftLeft(xx,k)) if k%2==1 else int(shiftRight(xx,k))",
      "pre_condition": "x and k should be non-negative integers.\n\nExamples:\n    check_pre_HE65(10,10) = True\n    check_pre_HE65(0,0) = True\n    check_pre_HE65(10,-1) = False\n",
      "pre_condition_incomplete": "def check_pre_HE65(x:int, k:int) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE65(x:int, k:int) -> bool:\n    return x>=0 and k>=0",
      "pre_condition_tests": "[[10,10], [0,0], [10,0], [-1,1],\n                           \"===\",\"===\",\n                           [123,3], [0,1], [-123,-1], [-123,0]\n                           ]",
      "post_condition": "Given two non-negative integers x and k, the integer y should be equal\nto the integer obtained by shifting the digits in x by k positions circularly towards\nthe left, if k is odd. And otherwise by k positions circularly towards\nthe right, if k is even.\nAny leading zero's in y are removed.\n\nExamples:\n    check_post_HE65(234561,123456,1) = True\n    check_post_HE65(456123,123456,3) = True\n    check_post_HE65(561234,123456,2) = True\n",
      "post_condition_incomplete": "def check_post_HE65(y:int, x:int, k:int) -> bool:",
      "post_condition_solution": "def check_post_solution_HE65(y:int, x:int, k:int) -> bool:\n\n    def shiftLeft(z,k):\n        for j in range(0,k):\n            z = z[1:] + z[0]\n        return z\n    def shiftRight(z,k):\n        N = len(z)\n        for j in range(0,k):\n            z = z[N-1] + z[0:N-1]\n        return z\n\n    if k%2==1:\n        return y == int(shiftLeft(str(x),k))\n    else:\n        return y == int(shiftRight(str(x),k))",
      "post_condition_tests": "[ [0,0,7], [7,7,7], [123,123,0],\n                              [21,21,2], [12,21,3],\n                              [1,10000,4],\n                              [456123,123456,3],\n                              \"===\",\n                              [0,123,0], [312,123,1], [231,123,4], [0,10,1],\n                              \"===\",\n                              [123,123,0], [234561,123456,1], [561234,123456,2],\n                              [1,1000,1], [10,1000,2], [9,9,9],\n                              [10,100,4], [1,1000,5],\n                              [234561,123456,2], [561234,123456,1],\n                              [1000,1000,5], [0,1000,5]\n                            ]",
      "prg_CC": 3,
      "pre_condition_CC": 2,
      "post_condition_CC": 2,
      "pre_condition_complexity": "S",
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE71",
      "program-desc": "Given a list z of integers, the program returns the number of elements in\nz that needs to be modified to turn z into a uniform list (a list consisting\nof all the same elements).\n\nExamples:\n    Pr_HE71([1,2])   = 1\n    Pr_HE71([2,1,2]) = 1\n    Pr_HE71([1,2,2]) = 1\n    Pr_HE71([2,0,3,0,2]) = 3\n",
      "program": "def Pr_HE71(z:list[int]) -> int :\n    U = set(z)\n    mostFrequent = 0\n    for x in U:\n        n = len([y for y in z if y==x])\n        if n > mostFrequent :\n            mostFrequent = n\n    return len(z) - mostFrequent",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "n should be equal to the number of elements in z that needs to be modified\nto turn z into a uniform list (a list consisting of all the same elements).",
      "post_condition_incomplete": "def check_post_HE71(n:int, z:list[int]) -> bool:",
      "post_condition_solution": "def check_post_solution_HE71(n:int, z:list[int]) -> bool:\n   if z==[]:\n       return n==0\n   return n == (len(z) - max([  sum([1 for y in z if y==x])  for x in set(z) ]))\n",
      "post_condition_tests": "[ [0,[]], [0,[1]],\n      [1,[1,2]], [1,[2,1,2]], [1,[1,2,2]],\n      [3, [2,0,3,0,2]],\n      \"===\",\n      [1,[1]], [2,[1,2,2]],\n      \"===\",\n      [1,[2,2,1,2]], [3,[1,2,3,4]],\n      [1,[1]], [2,[2,1,2]], [3,[2,1,2]], [2, [2,0,3,0,2]]\n    ]",
      "prg_CC": 5,
      "post_condition_CC": 5,
      "post_condition_complexity": "QQ"
   },
   {
      "task_id": "HE73",
      "program-desc": "Given a list s of strings, the program returns the average distance between\ndifferent strings. The resuling average is rounded down to an integer.\nThe distance between two strings is defined as the minimum number of\nedits to make the two strings equal. Difference in casing (lower or upper\ncase) is ignored.\nAn edit is either changing one character with another, or inserting a new\ncharacter. Insertion is only allowed at the end of a string.\n\nIf s contains less than two strings, None is returned.\n\nExamples:\n    Pr_HE73([\"hello AI\", \"Hello GPT\", \"HELLO LLM\"]) = 3\n    Pr_HE73([\"llama\", \"laama\", \"llama3\"]) = 1\n",
      "program": "def Pr_HE73(s:list[str]) -> int :\n\n    if len(s) < 2 : return None\n\n    def dist(u,v):\n         u = u.lower()\n         v = v.lower()\n         n = min(len(u),len(v))\n         D = 0\n         for k in range(n):\n              if u[k] != v[k] :\n                  D += 1\n         D += abs(len(u) - len(v))\n         return D\n\n    N = len(s)\n    pairs = [ (s[j],s[k]) for j in range(N) for k in range(j+1,N) ]\n    avrg = sum(dist(u,v) for (u,v) in pairs)/len(pairs)\n    import math\n    return math.floor(avrg)\n",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "Given a list s of strings, v should be equal to the average distance between\ndifferent strings. The resuling average is rounded down to an integer.\nThe distance between two strings is defined as the minimum number of\nedits to make the two strings equal. Difference in casing (lower or upper\ncase) is ignored.\nAn edit is either changing one character with another, or inserting a new\ncharacter. Insertion is only allowed at the end of a string.\n\nIf s contains less than two strings, v should be equal to None.\n\nExamples:\n    check_post_HE73(3, [\"hello AI\", \"Hello GPT\", \"HELLO LLM\"]) = True\n    check_post_HE73(1, [\"llama\", \"laama\", \"llama3\"]) = True\n\n",
      "post_condition_incomplete": "def check_post_HE73(v:int, s:list[str]) -> bool:",
      "post_condition_solution": "def check_post_solution_HE73(v:int, s:list[str]) -> bool:\n    if len(s) < 2 :\n        return v==None\n\n    def dist(u,v):\n        return len([(x,y) for (x,y) in zip(u.lower(),v.lower()) if x != y]) + abs(len(u) - len(v))\n\n    import statistics\n    import math\n    N = len(s)\n    avrg = statistics.mean([ dist(s[j],s[k]) for j in range(N) for k in range(j+1,N) ])\n    return v == math.floor(avrg)\n",
      "post_condition_tests": "[ [None,[]], [None,[\"hi\"]],\n      [3, [\"hello AI\", \"Hello GPT\", \"HELLO LLM\"]], [1, [\"llama\", \"laama\", \"llama3\"]],\n      [0,[\"abc\", \"ABC\"]], [3,[\"ab\", \"ABCD\", \"ABCDef\", \"abcdefGH\"]],\n      \"===\",\n      [1,[\"a\",\"A\"]], [0,[\"hi\"]], [0,[\"\",\"abc\",\"abc\"]], [3,[\"\",\"abc\",\"abc\"]],\n      \"===\",\n      [0,[\"abc\",\"ABC\",\"AbC\"]], [0,[\"\",\"\",\"\"]],\n      [2,[\"\",\"xyz\",\"xxx\",\"xyyx\"]], [2,[\"abcd\",\"abab\",\"A  D\", \"abcd\", \"\"]],\n      [2,[\"xx\",\"xx??\",\"xx\"]], [None,[\"a\",\"b\"]]\n    ]",
      "prg_CC": 5,
      "post_condition_CC": 4,
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE74",
      "program-desc": "The program is given two lists of strings s and t. Every string in the lists represents\nan integer. The program returns the list (s or t) whose sum of all the integers\nin it is smaller than those in the other list. If the sums are equal, the\nprogram returns s.\n\nExamples:\n    Pr_HE74(['10'],['-1','0']) = ['-1','0']\n    Pr_HE74(['10'],['9','1']) = ['10']\n    Pr_HE74(['1'],[]) = []\n",
      "program": "def Pr_HE74(s:list[str], t:list[str]) -> list[str] :\n    sumS = 0\n    for x in s:\n        sumS += int(x)\n    sumT = 0\n    for x in t:\n        sumT += int(x)\n    if sumS < sumT :\n        return s\n    if sumS == sumT:\n        return s\n    return t",
      "pre_condition": "Every string in s and t represents an integer.\n\nExamples:\n    check_pre_HE74(['10'],['-1','0']) = True\n    check_pre_HE74(['-1.2'],[]) = False\n    check_pre_HE74(['-1'],['abc']) = False\n",
      "pre_condition_incomplete": "def check_pre_HE74(s:list[str], t:list[str]) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE74(s:list[str], t:list[str]) -> bool:\n    def isInt(u):\n        try:\n            x = int(u)\n            return True\n        except:\n            return False\n\n    return all([isInt(x) for x in s]) and all([isInt(x) for x in t])",
      "pre_condition_tests": "[[['10'],['-1','0']], [[],['-1','0']], [['-1.2'],[]], [['-1'],['abc']],\n                           \"===\",\"===\",\n                           [[],[]], [['1','1','0'],['-1','-2']],\n                           [['-1.2'],['0.001']], [['20x'],['10']]\n                           ]",
      "post_condition": "Given lists of strings s and t where every string represents an integer, the list\nr should be equal to s if the sum of all integers in s is smaller than those in t.\nElse, r should be equal to t.\nHowever, if the sums are the same, r should be equal to s.\n\nExamples:\n    check_post_HE74(['-1','0'],['10'],['-1','0']) = True\n    check_post_HE74(['10'],['10'],['9','1']) = True\n    check_post_HE74(['9','1'],['10'],['9','1']) = False\n",
      "post_condition_incomplete": "def check_post_HE74(r:list[str], s:list[str], t:list[str]) -> bool:",
      "post_condition_solution": "def check_post_solution_HE74(r:list[str], s:list[str], t:list[str]) -> bool:\n    if sum([int(x) for x in s]) <= sum([int(x) for x in t]):\n        return r==s\n    return r==t",
      "post_condition_tests": "[ [[],[],[]],\n                              [[],['1','2'],[]],\n                              [['1','-2'],['1','-2'],[]],\n                              [['-1','0'],['10'],['-1','0']],\n                              [['10'],['10'],['9','1']],\n                              \"===\",\n                              [[],['1','-2'],[]],\n                              [['9','1'],['10'],['9','1']],\n                              [['10'],['10'],['-1','0']],\n                             \"===\",\n                              [['1','2','29'],['1','2','30'],['1','2','29']],\n                              [[],['1','2','30'],[]],\n                              [[],[],['1','2','30']],\n                              [[],[],['1','-1']],\n                              [['1','-1'],['1','-1'],[]],\n                              [['1','2','29'],['1','1','1'],['1','2','29']],\n                              [[],[],['1','-2']],\n                              [['1','2'],['2'],['1','2']]\n                            ]",
      "prg_CC": 5,
      "pre_condition_CC": 4,
      "post_condition_CC": 4,
      "pre_condition_complexity": "Q",
      "post_condition_complexity": "Q"
   },
   {
      "task_id": "HE80",
      "program-desc": "Given a string s that only contains letters, the program returns true\nif and only if the string t is at least three letters long and furthermore\nevery three consecutive letters in t are distinct.\nt is a string obtained by turning all letters in s to upper case.\n\nExamples:\n    Pr_HE80('aa')   = False\n    Pr_HE80('abcd') = True\n    Pr_HE80('aAbC') = False\n    Pr_HE80('xyy')  = False",
      "program": "def Pr_HE80(s) :\n    if len(s) < 3:\n      return False\n    s = s.upper()\n    for i in range(len(s) - 2):\n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True",
      "pre_condition": "The string s only contains letters.",
      "pre_condition_incomplete": "def check_pre_HE80(s: str) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE80(s: str) -> bool:\n   return all([c.isalpha()  for c in s])",
      "pre_condition_tests": "[[\"123abc\"],[\"AbCDeFGG\"],[\"a-bcdef+\"],[\"\"],\"===\",\"===\", [\"aaaA\"], [\"A\"], [\"ab cd\"] , [\"ab@cd\"]]",
      "post_condition": "retval is true if and only if the string t is at least three letters long and furthermore\nevery three consecutive letters in t are distinct.\nt is a string obtained by turning all letters in s to upper case.\n\nExamples:\n    check_post_HE80(False, 'aa')   = True\n    check_post_HE80(True, 'abcd')  = True\n    check_post_HE80(False, 'aAbC') = True\n    check_post_HE80(False, 'xyy')  = True",
      "post_condition_incomplete": "def check_post_HE80(retval:bool, s:str) -> bool:",
      "post_condition_solution": "def check_post_solution_HE80(retval:bool, s:str) -> bool:\n    s = s.upper()\n    expected = len(s) >= 3 and all([ a!=b and b!=c and a!=c for (a,b,c) in zip(s,s[1:],s[2:])])\n    return retval == expected",
      "post_condition_tests": "[ [True,\"abcd\"], [True,\"adb\"], [False,\"abAd\"], [True,\"BdfhJlbdhf\"], [False,\"abcdabA\"], [False,\"a\"],\n                              \"===\",\n                              [True,\"abB\"],[True,\"abcbac\"],\n                              \"===\",\n                              [True,\"xyzbca\"], [False,\"aAbBcC\"], [False,\"ab\"],\n                              [True,\"aa\"], [False,\"aabb\"], [True,\"xyy\"], [True,\"aAZbcd\"], [True,\"abcabbcabc\"] ]",
      "prg_CC": 6,
      "pre_condition_CC": 2,
      "post_condition_CC": 5,
      "pre_condition_complexity": "Q",
      "post_condition_complexity": "Q"
   },
   {
      "task_id": "HE84",
      "program-desc": "Given a positive integer, the program returns the product of the digits in the integer.\nThe product is returned as a base-two number in a string.\n\nExamples:\n    Pr_HE84(123) = \"110\"\n    Pr_HE84(17) = \"111\"\n",
      "program": "def Pr_HE84(x:int) -> str :\n    product = 1\n    for dig in str(x):\n        product = product * int(dig)\n    return bin(product)[2:]",
      "pre_condition": "x is a positive integer.",
      "pre_condition_incomplete": "def check_pre_HE84(x:int) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE84(x:int) -> bool:\n   return x>0",
      "pre_condition_tests": "[\n    [1], [99] , [0], [-3],\n    '===', '===',\n    [2], [10] , [0], [-1]\n    ]",
      "post_condition": "Let y be the product of the digits in the integer x.\nr should be a string representing y as a base-two number.\n\nExamples:\n    check_post_HE84(\"110\",123) = True\n    check_post_HE84(\"111\",17)  = True",
      "post_condition_incomplete": "def check_post_HE84(r:str, x:int) -> bool :",
      "post_condition_solution": "def check_post_solution_HE84(r:str, x:int) -> bool :\n    product = 1\n    for dig in str(x):\n        product = product * int(dig)\n    y = 0\n    for c in r :\n        y = 2*y\n        if c == '1' :\n            y = y+1\n        elif c != '0' :\n            return False\n    return y==product",
      "post_condition_tests": "[\n    [\"110\",123],\n    [\"111\",17],\n    [\"1\",1],\n    [\"111\",7],\n    [\"0\",70],\n    \"===\",\n    [\"111\",70],\n    [\"7\",17],\n    \"===\",\n    [\"0\",2890],\n    [\"100\",21112],\n    [\"1101001\",1357],\n    [\"6\",123],\n    [\"11\",111]\n    ]",
      "prg_CC": 2,
      "pre_condition_CC": 1,
      "post_condition_CC": 5,
      "pre_condition_complexity": "S",
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE86",
      "program-desc": "Given a string s, the program returns a string t obtained by replacing every\nword in s with its sorted variant. The distinction between lower and upper\ncases are ignored when sorting.\nWords are assumed to be separated by one or more spaces. The result string t\nshould maintain the original spacing between words.\n\nExamples:\n    Pr_HE86(\"abC  cba  321\") = \"abC  abc  123\"\n",
      "program": "def Pr_HE86(s:int) -> str :\n    t = \"\"\n    word = \"\"\n    for c in s:\n        if c==' ':\n            if word != \"\":\n                w2 =  \"\".join(sorted(word, key=lambda c: c.lower()))\n                #print(f\">>> orig:{word}  srt:{w2}\")\n                t += w2\n                word = \"\"\n            t += c\n        else :\n            word += c\n    t += \"\".join(sorted(word, key=lambda c: c.lower()))\n    return t",
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "Given a string s, the string t should be equal to the string obtained by replacing every\nword in s with its sorted variant. The distinction between lower and upper\ncases are ignored when sorting.\nWords are assumed to be separated by one or more spaces. The string t\nshould maintain the same spacing between words that were in s.\n\nExamples:\n    check_post_HE86(\"abC  abc  123\",\"abC  cba  321\") = True\n",
      "post_condition_incomplete": "def check_post_HE86(t:str, s:str) -> bool :",
      "post_condition_solution": "def check_post_solution_HE86(t:str, s:str) -> bool :\n\n    def takeWhile(p,z):\n        if z==\"\":\n            return ([],\"\")\n        #print(f\">>> z={z}\")\n        if p(z[0]):\n            (pref,rest) = takeWhile(p,z[1:])\n            return ([z[0]] + pref, rest)\n        return ([],z)\n\n    def chunks(z):\n        if z==\"\": return []\n        (seg,rest) = takeWhile(lambda c: c==' ', z)\n        if (seg==[]):\n            (seg,rest) = takeWhile(lambda c: c != ' ', z)\n        return [seg] + chunks(rest)\n\n    theChunks = chunks(s)\n    zz = \"\".join([ \"\".join(sorted(seg, key=lambda c: c.lower())) for seg in theChunks])\n    return t == zz",
      "post_condition_tests": "[\n    [\"  \", \"  \"], [\"abc 123\", \"cba 321\"], [\" c  b   a    \", \" c  b   a    \"],\n    [\"abC  abc  123\",\"abC  cba  321\"], [ \"  !12?ab  !12?AB\", \"  ba21!?  BA21!?\"],\n    \"===\",\n    [\"a\", \" a \"],  [\"Ba\",\"Ba\"], [\"ab ba\",\"ba ba\"], [\"ab12\",\"ab12\"],\n    \"===\",\n    [\"ehllo  !dlorW\", \"hello  World!\"], [\"123aBc\",\"321Bca\"], [ \" -3  *0  ?a \", \" 3-  0*  a? \"],\n    [\"\",\"   \"], [\"a\",\" ba \"], [\"ab\",\" ba \"]\n    ]",
      "prg_CC": 4,
      "post_condition_CC": 2,
      "post_condition_complexity": "NQ"
   },
   {
      "task_id": "HE90",
      "program-desc": "Given a list s of numbers, the program returns the k-th smallest number in s.\nWe start counting at 1.\nIf the length of s is less than k, we first pad s with a value v until its\nlength is equal to k. The value v is equal to the original length of s.\n\nExamples\n   Pr_HE90([1,5,0],1) = 0\n   Pr_HE90([1,5,0],2) = 1\n   Pr_HE90([5,5],4) = 5\n   Pr_HE90([0,0],4) = 2\n",
      "program": "def Pr_HE90(s:list[float], k:int) :\n    if s==[]:\n        return 0\n    if k <= len(s) :\n       return sorted(s)[k-1]\n    n = len(s)\n    z = s + ([n] * (k-n))\n    return sorted(z)[k-1]",
      "pre_condition": "k is a positive integer.",
      "pre_condition_incomplete": "def check_pre_HE90(s:list[float], k:int) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE90(s:list[float], k:int) -> bool:\n    return k>0",
      "pre_condition_tests": "[ [[], 1], [[1],10], [[1,2],0], [[1,2],-1],\n                            \"===\", \"===\",\n                            [[10],10], [[-10],-10]\n                            ]",
      "post_condition": "Given a list s of numbers, r should be equal to the k-th smallest number in s.\nWe start counting at 1.\nIf the length of s is less than k, we first pad s with a value v until its\nlength is equal to k. The value v is equal to the original length of s.\n\nExamples\n   check_post_HE90(0,[1,5,0],1) = True\n   check_post_HE90(1,[1,5,0],2) = True\n   check_post_HE90(5,[5,5],4) = True\n   check_post_HE90(2,[0,0],4) = True",
      "post_condition_incomplete": "def check_post_HE90(r:int, s:list[float], k:int) -> bool:",
      "post_condition_solution": "def check_post_solution_HE90(r:int, s:list[float], k:int) -> bool:\n   n = len(s)\n   z = s + ([n] * (k-n))\n   return r ==  sorted(z)[k-1]",
      "post_condition_tests": "[\n            [0,[1,5,0],1] , [1,[1,5,0],2], [5,[5,5],4], [2,[0,0],4],\n            [0,[],4],\n            \"===\",\n            [1,[0,1,2],1], [2,[0,0,2],2], [2,[5,5],3], [0,[0,0],3],\n            \"===\",\n            [0,[],1], [-1,[-1],1], [3,[3],2], [1,[-1],2],\n            [1,[0,1,2,3],1], [4,[0,1,2,3],4], [5,[0,1,2,3],5],\n            [4,[0,1,2,6],5]\n            ]",
      "prg_CC": 3,
      "pre_condition_CC": 1,
      "post_condition_CC": 1,
      "pre_condition_complexity": "S",
      "post_condition_complexity": "S"
   },
   {
      "task_id": "HE99",
      "program-desc": "Given a string s which is assumed to represent some number x, the program\nreturns an integer k with the smallest distance to x.\nHowever, if x is exactly in the middle between two integers, the k closest to\n0 is returned.\n\nExamples\n   Pr_HE99(\"9.4\")  = 9\n   Pr_HE99(\"8.5\")  = 8\n   Pr_HE99(\"9\")    = 9\n   Pr_HE99(\"-8.5\") = -8\n",
      "program": "def Pr_HE99(s:str) :\n    from math import floor, ceil\n    num = float(s)\n    x = abs(num)\n    low = floor(x)\n    high = ceil(x)\n    dlow = x - low\n    dhigh = high - x\n    if low == high:\n        return low\n    if dhigh < dlow :\n        return high if num>0 else -high\n    elif dlow < dhigh :\n        return low if num>0 else -low\n    else: #dlow == dhigh\n        return low if num>0 else -low",
      "pre_condition": "The string s must represent a number.",
      "pre_condition_incomplete": "def check_pre_HE99(s: str) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE99(s: str) -> bool:\n    try:\n        float(s)\n    except:\n        return False\n    return True",
      "pre_condition_tests": "[[\"\"],[\"10\"],[\"15.3\"],[\"-3.12542\"],[\"5.0.0\"],[\"test\"],[\"18-18\"],\n                            \"===\",\"===\",\n                            [\"15:20\"], [\"06-280280\"], [\"2F0\"]\n                            ]",
      "post_condition": "Given a string s which is assumed to represent some number x, retval should be\nequal to an integer k with the smallest distance to x.\nHowever, if x is exactly in the middle between two integers, retval should be\nequal to the k closest to 0.\n\nExamples\n   check_post_HE99(9, \"9.4\")  = True\n   check_post_HE99(8, \"8.5\")  = True\n   check_post_HE99(9, \"9\")    = True\n   check_post_HE99(-8, \"-8.5\") = True\n",
      "post_condition_incomplete": "def check_post_HE99(retval: int, s: str) -> bool:",
      "post_condition_solution": "def check_post_solution_HE99(retval: int, s: str) -> bool:\n    from math import floor, ceil\n    x = float(s)\n    x0 = floor(x)\n    x1 = ceil(x)\n    r = round(x)\n    if abs(x - x0) != abs(x - x1):\n        return retval == r\n    else :\n        return retval == (x0 if x >= 0 else x1)",
      "post_condition_tests": "[\n            [0,\"0\"],[10,\"10\"],[15,\"15.3\"],[16,\"15.55\"],[14,\"14.5\"],[-14,\"-14.5\"], [-15,\"-14.5001\"],\n            \"===\",\n            [16,\"14.5\"], [-15,\"-14.5\"],\n            \"===\",\n            [11,\"11\"],[8,\"8.50\"],[-3,\"-3.12542\"],[-4,\"-3.5001\"],[0,\"0.10000\"],[16,\"15.3\"],[14,\"14.5\"],[-4,\"-3.12542\"]]",
      "prg_CC": 7,
      "pre_condition_CC": 2,
      "post_condition_CC": 3,
      "pre_condition_complexity": "S",
      "post_condition_complexity": "S"
   }
]