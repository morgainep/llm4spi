[
   {
      "task_id": "HE0",
      "program-desc": "The program checks whether the given list z contains two elements whose sum is greater than a.\n\nExamples:\n    Pr_HE0([1.0, 2.0, 3.0], 6) = False\n    Pr_HE0([1.0, 2.8, 3.0, 4.0, 2.0, 5.0], 8.99) = True\n",
      "program": "def Pr_HE0(z:list[float], a:float) -> bool :\n    for idx, elem in enumerate(z):\n        for idx2, elem2 in enumerate(z):\n            if idx != idx2:\n                if elem + elem2 > a:\n                    return True\n\n    return False",
      "prg_CC" : 5,
      "pre_condition": "",
      "pre_condition_incomplete": "",
      "pre_condition_solution": "",
      "pre_condition_tests": "",
      "post_condition": "r should be equivalent to whether z contains two elements whose sum is greater than a.\n\nExamples:\n    check_post_HE0(False, [1.0, 2.0, 3.0], 6) = True\n    check_post_HE0(True, [1.0, 2.8, 3.0, 4.0, 2.0, 5.0], 8.99) = True",
      "post_condition_incomplete": "def check_post_HE0(r:bool, z:list[float], a:float) -> bool :",
      "post_condition_solution": "def check_post_solution_HE0(r:bool, z:list[float], a:float) -> bool :\n    N = len(z)\n    expected = any([ any([ z[i] + z[k] > a\n                         for k in range(N) if k!=i ])\n                 for i in range(N)])\n    return r == expected",
      "post_condition_complexity": "QQ",
      "post_condition_CC" : 4,
      "post_condition_tests": "[\n    [False, [],0],\n    [False, [1],0],\n    [True, [1,0,8,-1], 8.99],\n    [False, [1,0,8,-1], 9],\n    \"===\",\n    [True, [1,1,1], 2],\n    [True, [0],0 ],\n    \"===\",\n    [True, [1,1,1,1], 1.99],\n    [True, [2,1,1,3], 4.99],\n    [True, [1.0, 2.8, 3.0, 4.0, 2.0, 5.0], 8.99],\n    [False, [9],0],\n    [False, [1,1,1,1], 0],\n    [False, [1.0, 2.0, 3.0], 5],\n    [False, [1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 4]\n    ]"
   },
   {
      "task_id": "HE1",
      "program-desc": "The program is given a string s, assumed to contain one or more cp-segments. \nA cp-segment starts with '(' and is closed with ')' and recursively may contain \nmultiple inner cp-segments.\nThe program returns a list r,  consisting of the cp-segments of s as separate strings. \nSo, every r[i] is a  cp-segment of s.\nWhen joined, all the strings in r should give a string z that is equal to s.\n\nExamples:\n    Pr_HE1('()()') =  ['()', '()']\n    Pr_HE1('(())') =  ['(())' ]\n    Pr_HE1('(())(()())') =  ['(())', '(()())']\n",
      "program": "def Pr_HE1(s:str) -> list[str] :\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in s:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result",
      "prg_CC" : 5,
      "pre_condition": "s is expected to contain one or more cp-segments. A cp-segment starts \nwith '(' and is closed with ')' and recursively may contain \nmultiple inner cp-segments.\n\nExamples:\n    check_pre_HE1('()') = True\n    check_pre_HE1('()()') = True\n    check_pre_HE1('(())') = True\n    ",
      "pre_condition_incomplete": "def check_pre_HE1(s:str) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE1(s:str) -> bool:\n    if len([c for c in s if c != '(' and c!=')']) > 0 :\n        return False\n    stack = 0 # keep track of how many '(' found so far wich have not been closed\n    for c in s:\n        if c == ')' and stack==0: return False\n        elif c == ')':\n            stack = stack-1\n        else :\n            stack = stack+1\n    return stack == 0",
      "pre_condition_complexity": "NQ",
      "pre_condition_CC" : 9,
      "pre_condition_tests": "[[''],['()'],['()(()())()'],[' ( ) '], ['('], \n                           \"===\",\n                           ['()(())(()())'],\n                           [')()'],['())'],['()('],['(ab)'],['()()x']\n                           ]",
      "post_condition": "The list r should contain the cp-segments of s as separate strings. \nSo, every r[i] is a  cp-segment of s.\nA cp-segment starts with '(' and  is closed with ')' and recursively \nmay contain multiple inner cp-segments.\nWhen joined, all the strings in r should give a string z that is equal to s.\n\nExamples:\n    check_post_HE1(['()', '()'], '()()') = True\n    check_post_HE1(['(())' ], '(())') = True\n    check_post_HE1(['(())', '(()())'], '(())(()())') =  True\n",
      "post_condition_incomplete": "def check_post_HE1(r:list[str], s:str) -> bool:",
      "post_condition_solution": "def check_post_solution_HE1(r:list[str], s:str) -> bool:\n    z = [c for c in s if c != ' ']\n    if len(z) == 0 : return len(r) == 0\n\n    def ok(segment:str) -> bool:\n        if len(segment) == 0 : return False\n        if len([c for c in segment if c != '(' and c!=')']) > 0 :\n            return False\n        stack = 0 # keep track of how many '(' found so far wich have not been closed\n        while len(segment) > 0 :\n            c = segment[0]\n            segment = segment[1:]\n            if c == ')' and stack==0: return False\n            elif c == ')':\n                stack = stack-1\n                if stack == 0 and len(segment)>0 : return False\n            else :\n                stack = stack+1\n        return stack == 0\n\n\n    return  all([ok(segment) for segment in r]) and  ''.join(r) == ''.join(z)",
      "post_condition_complexity": "NQ",
      "post_condition_CC" : 6,
      "post_condition_tests": "[ [[],''],\n                             [['()'],'()'],\n                             [['()','(()())','()'],'()(()())()'],\n                             \"===\",\n                             [['(())()' ] , '(())()'],\n                             [['(())' ] , '(())()'],\n                             \"===\",\n                             [['()','()'],'()()'],\n                             [['(())'],'(())'],\n                             [['()','(())','(()())'],'()(())(()())'],\n                             [['','()'],'()'],\n                             [['()(',')'],'()()'],\n                             [['()()'],'()()']\n                            ]"
   },
   {
      "task_id": "HE120",
      "program-desc": "Given non-empty a list A of numbers, the program returns a longest sorted segment of A,\nwhose length is at most k. k is at least one.\n\nExamples:\n    Pr_HE120([3,1,2,3,4],4) = [1,2,3,4]\n    Pr_HE120([3,1,2,3,4],2) = [1,2] ([2,3] is also ok)\n",
      "program": "def Pr_HE120(A:list[float], k:int) -> list[float] :\n    segments = []\n    for i in range(len(A)):\n        for v in range(i+1,len(A)+1):\n            z = A[i:v]\n            if z == sorted(z) : segments.append(z)\n    longest = []\n    for z in segments:\n        if len(z) == k: return z\n        if len(z) > len(longest) : longest = z\n    return longest",
      "prg_CC" : 7,
      "pre_condition": "A is non-empty and k is at least one.",
      "pre_condition_incomplete": "def check_pre_HE120(A:list[float], k:int) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE120(A:list[float], k:int) -> bool:\n    return A != [] and k > 0",
      "pre_condition_complexity": "S",
      "pre_condition_CC" : 2,
      "pre_condition_tests": "[ \n    [[1],1], [[1,2], 5], [[],1], [[1,2], 0],\n    \"===\",\n    [[1,2,3],-1], [[],0]\n    ]",
      "post_condition": "Given a non-empty list A of numbers, r should be equal to a longest sorted segment of A,\nwhose length is at most k.\n\nExamples:\n    check_post_HE120([1,2,3,4], [3,1,2,3,4], 4) = True\n    check_post_HE120([1,2], [3,1,2,3,4], 2) =  True",
      "post_condition_incomplete": "def check_post_HE120(r:list[float], A:list[float], k:int) -> bool :",
      "post_condition_solution": "def check_post_solution_HE120(r:list[float], A:list[float], k:int) -> bool :\n    if len(r) > k :\n        return False\n    segments = []\n    for i in range(len(A)):\n        for y in range(i+1,len(A)+1):\n            z = A[i:y]\n            if z == sorted(z) : segments.append(z)\n    return r in segments  and len(r) == max([len(z) for z in segments if len(z) <= k])",
      "post_condition_complexity": "NQ",
      "post_condition_CC" : 8,
      "post_condition_tests": "[\n    [ [1,2,3,4], [3,1,2,3,4], 4] , \n    [ [1,1], [3,1,1,3,4], 2 ] ,\n    [ [3], [3,1,2,3,4], 1 ] ,\n    [ [1,2,3], [3,1,2,0,1,2,3,0], 3 ] ,\n    [ [3], [3], 3 ] ,\n    \"===\",\n    [ [1,1,1], [1,1,1], 2 ] ,\n    [ [1,2,3,0], [1,2,3,0], 4 ] ,\n    \"===\",\n    [ [2,3], [3,1,2,3,4], 2 ] ,\n    [ [1,2,3], [3,1,2,3,0], 3 ] ,\n    [ [1,2,3], [3,1,2,3,4], 4] , \n    [ [3,1,2,3], [3,1,2,3,4], 4] , \n    [ [1,2,3,4], [3,1,2,3,4], 2 ] ,\n    [ [1,2], [3,1,2,3,4], 1 ] ,\n    [ [1,2], [3,1,2,0,1,2,3,0], 3 ] \n    ]"
   },
   {
      "task_id": "HE13",
      "program-desc": "Given a non-empty list s of positive integers, the program return the greatest common divisor of\nthe integers in s.\n\nExamples:\n    Pr_HE13([4,6,8]) =  3\n    Pr_HE13([4,6,9]) =  1\n    Pr_HE13([10,25,40]) =  5\n",
      "program": "def Pr_HE13(s:list[int]) -> int :\n    smallest_x = min(s)\n    if smallest_x <= 1: return 1\n    greatest = 1\n    for d in range(1, smallest_x + 1):\n        if all([ x%d == 0 for x in s]):\n            greatest = d\n    return greatest",
      "prg_CC" : 5,
      "pre_condition": "s is a non-empty list of positive integers.",
      "pre_condition_incomplete": "def check_pre_HE13(s:list[int]) -> bool:",
      "pre_condition_solution": "def check_pre_solution_HE13(s:list[int]) -> bool:\n    return s != [] and all([x>0 for x in s])",
      "pre_condition_complexity": "Q",
      "pre_condition_CC" : 3,
      "pre_condition_tests": "[ \n    [[1,2,3]], [[1,2,-3]], [[]], [[0]],\n    \"===\",\n    [[2]], [[2,-1,-1]], [[1,2,3,4,5,0]]\n    ]",
      "post_condition": "The value r should be equal to the greatest common divisor of the integers in s.",
      "post_condition_incomplete": "def check_post_HE13(r:int, s:list[int]) -> bool:",
      "post_condition_solution": "def check_post_solution_HE13(r:int, s:list[int]) -> bool:\n    smallest_x = min(s)\n    if smallest_x <= 1: return 1\n    greatest = 1\n    for d in range(1, smallest_x + 1):\n        if all([ x%d == 0 for x in s]):\n            greatest = d\n    return r == greatest",
      "post_condition_complexity": "QQ",
      "post_condition_CC" : 4,
      "post_condition_tests": "[ \n    [100, [100]],\n    [2, [4,6,8]],\n    [1, [4,6,9]],\n    [3, [6,9,27]],\n    \"===\",\n    [5, [5,25,12]],\n    [4, [16,8,24]],\n    \"===\",\n    [5, [10,25,40]],\n    [1, [4,6,8]],\n    [4, [4,6,8]],\n    [0, [4,8]],\n    [2, [4,8]]\n    ]          "
   },
   {
      "task_id": "HE132",
      "program-desc": "Given a string s that is assumed to contain only square brackets, the program\nreturns True if and only if the string contains a segment z made of properly closed \nbrackets that contains another segment z2 of properly closed brackets. \nA segment is properly closed if it starts with '[' and is ended with ']'.\n\nExamples:\n    Pr_HE132('[]') = False\n    Pr_HE132('[][]') = False\n    Pr_HE132('[[]]') = True\n    Pr_HE132('[[][]]') = True\n    Pr_HE132('[[]][') = True\n    Pr_HE132('[]]]][[[[]') = False\n ",
      "program": "def Pr_HE132(s:str) -> bool: \n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(s)):\n        if s[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2",
      "prg_CC" : 7,
      "pre_condition": "The string s contains only square brackets.",
      "pre_condition_incomplete": "def check_pre_HE132(s:str) -> bool: ",
      "pre_condition_solution": "def check_pre_solution_HE132(s:str) -> bool: \n    return all([c == '[' or c==']' for c in s ])",
      "pre_condition_complexity": "Q",
      "pre_condition_CC" : 3,
      "pre_condition_tests": "[['[[[[['],[''],['[][]'],['[aaabcd]'],['[][][] '], [']'],\n                             \"===\",\n                             [']['], ['()'],[']]'],['[  ]']\n                             ]",
      "post_condition": "Given a string s that is assumed to contain only square brackets, retval should\nbe equivalent to whether the string contains a segment z made of properly closed \nbrackets that contains another segment z2 of properly closed brackets. \nA segment is properly closed if it starts with '[' and is ended with ']'.\n\nExamples:\n    check_post_HE132(False, '[]') = True\n    check_post_HE132(False, '[][]') = True\n    check_post_HE132(True, '[[]]') = True\n    check_post_HE132(True, '[[][]]') = True\n    check_post_HE132(True, '[[]][') = True\n    check_post_HE132(False, '[]]]][[[[]') = True",
      "post_condition_incomplete": "def check_post_HE132(retval: bool, s : str) -> bool:",
      "post_condition_solution": "def check_post_solution_HE132(retval: bool, s : str) -> bool:\n    stack = 0 # keep track of how many '[' found so far wich have not been closed\n    maxStackDepth = 0\n    expected = False\n    for c in s:\n        if c == ']' and stack==0: continue\n        elif c == ']':\n            stack = stack-1\n            if maxStackDepth - stack == 2:\n                # found a segment with a nested brackets\n                expected = True\n                break\n        else :\n            # then c must me a ']', given the assumption that s contains only\n            # square brackets\n            stack = stack+1\n            if stack > maxStackDepth : maxStackDepth = stack\n\n    return retval == expected",
      "post_condition_complexity": "NQ",
      "post_condition_CC" : 7,
      "post_condition_tests": "[  [True,'[[]]'],\n                                [True,'[[][]]'],\n                                [True,'[[]][['],\n                                [True,'[[[[[[[[[[]]'],\n                                [True,']][][]]][[][]]]]'],\n                                \"===\",\n                                [False,']][[]]'], [False,'[[][]]'],\n                                \"===\",\n                                [False,'[][][[[]'],[False,'[[[[[][[][]'],\n                                [True,'[]]]]]]][[[[[]'],[True,'[][]'],[True,'[]'],[True,'[][[[[[[[[]']\n                             ]"
   }
]
