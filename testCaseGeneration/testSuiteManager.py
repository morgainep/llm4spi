import ast
import inspect
import types
import typing



# Given a test suite generated by pynguin,
# the function returns a dictionary with an entry for each test case.
def extractTests(testSuite: str) -> [] or None:

    # parse and create AST
    try:
        tree = ast.parse(testSuite)
    except SyntaxError as e:
        print(f"Error: Syntax error identified when parsing test suite")
        print(e)
        return None

    # extract test functions
    testFunctions = [
        node for node in ast.walk(tree)
        if isinstance(node, ast.FunctionDef) and node.name.startswith('test_') # pynguin can define helper functions
    ]

    # testsList = {}

    testsList = []

    # create the json
    for tf in testFunctions:
        # extract name
        for node in ast.walk(tf):
            if isinstance(node, ast.FunctionDef):
                # print(f"{node.name}")
                # testsList[node.name] = ast.unparse(node)
                testsList.append(ast.unparse(node))

    return testsList




# evaluate an assign and return it values
def evaluate_ast_node(node, scope):
    try:
        if isinstance(node, ast.Name):
            if node.id in scope:
                return evaluate_ast_node(scope[node.id], scope)  # Recursive evaluation
            else:
                return f"<variable: {node.id}>"
        elif isinstance(node, ast.Constant):
            return node.value
        elif isinstance(node, ast.FormattedValue):
            return node.value
        elif isinstance(node, ast.List):
            return [evaluate_ast_node(elt, scope) for elt in node.elts]
        elif isinstance(node, ast.Tuple):
            return tuple(evaluate_ast_node(elt, scope) for elt in node.elts)
        elif isinstance(node, ast.Dict):
            # print("************ DICTIONARY ***************")
            outDict = []
            for key, value in node:
                outDict[evaluate_ast_node(key, scope)] = evaluate_ast_node(value,scope)
            return outDict
        else:
            #return f"<expression: {ast.unparse(node).strip()}>" # Complex expressions not handled
            try:
                val = float(ast.unparse(node).strip())
                return val
            except:
                return ast.unparse(node).strip()
    except (ValueError, TypeError, SyntaxError, MemoryError) as e:
        print(e)
        return f"<evaluation_error: {ast.unparse(node).strip()}>" # Evaluation error


# Parse a test case and extract the inputs passed when program under test is called.
# Program under test can be invoked multiple times in a test case
def getInputVectorFromTestFunction(testCase: str, muduleName: str) -> [] or None:

    # parse function and create AST
    try:
        test_func = ast.parse(testCase)
    except SyntaxError as e:
        print(f"Error: Syntax error identified when parsing test case")
        print(e)

        return None

    scope = {}
    testSuiteVector = []
    testCaseVector = []
    for node in ast.walk(test_func):
        # store assignements
        if isinstance(node, ast.Assign):
            for target in node.targets:
                if isinstance(target, ast.Name):
                    scope[target.id] = node.value
                    # print(f"{target.id} = {ast.unparse(node.value)}")
        if isinstance(node, ast.Call):

            if not node.args and not node.keywords:
                # print("    No arguments passed.")
                continue
            else:
                for arg in node.args:
                    arg_value = evaluate_ast_node(arg, scope)
                    testCaseVector.append(arg_value)
            testSuiteVector.append(testCaseVector)
            testCaseVector = []
            # print(f"{ast.unparse(node.func)}")
            # print(*testCaseVector, sep="\t")

    # print(*testSuiteVector, sep=" ")
    return testSuiteVector

# Checks if the type of value 'val' matches type 'typ'.
def is_type_compatible(val, typ) -> bool:

    origin = typing.get_origin(typ)
    args = typing.get_args(typ)

    if val is None:
        if typ is type(None):
            return True
        return False

    if origin is None:
        if isinstance(val, typ):
            return True
        if typ is str and not isinstance(val, str):
            return False
        if typ is float and isinstance(val,int):
            return True
        if typ is complex and isinstance(val, (int, float)):
            return True
        if isinstance(val, bool) and typ not in [bool, object, typing.Any]:
            return False
        return False
        # try:
        #     res = typ(val)
        #     return isinstance(res, typ) and not isinstance(val, bool)
        # except (ValueError, TypeError):
        #     return False

    if origin is list:
        if not isinstance(val, list):
            return False
        (item_type,) = args
        return all(is_type_compatible(item, item_type) for item in val)

    if origin is tuple:
        if not isinstance(val, tuple):
            return False
        if len(args) == 2 and args[1] is Ellipsis:
            return all(is_type_compatible(item, args[0]) for item in val)
        if len(args) != len(val):
            return False
        return all(is_type_compatible(v, t) for v, t in zip(val, args))

    if origin is dict:
        if not isinstance(val, dict):
            return False
        key_type, value_type = args
        return all(
            is_type_compatible(k, key_type) and is_type_compatible(v, value_type)
            for k, v in val.items()
        )

    return False





# execute a function with the given actual parameters
# there are serveral limitations
def executeFunction(functionCode: str, actualParameters: []):
    namespace = {}

    # try to exec the function code to check for syntax or other types of error
    try:
        exec(functionCode, namespace)
    except SyntaxError as e:
        raise SyntaxError(f"Invalid syntax in function string: {e}") from e
    except Exception as e:
        # Catch other potential errors during definition (rare, but possible)
        raise RuntimeError(f"Error executing function definition string: {e}") from e

    # Find the function object that was defined in the namespace
    defined_functions = {
        name: obj
        for name, obj in namespace.items()
        # Check if it's a function object defined within the exec'd code
        if isinstance(obj, types.FunctionType) and obj.__module__ == namespace.get('__name__')
    }

    # Get the single function object and the function name
    functionCode_name, functionCode_F = list(defined_functions.items())[0]

    try:
        # extract function signature to get formal parameters
        sig = inspect.signature(functionCode_F)
        parameters = sig.parameters

        # check if the length formal and actual parameters match oth return None
        # print(f"Actual parameters {actualParameters}")
        if (len(actualParameters) == len(parameters.keys())):
            # create argument to run function
            functionArgs = {}
            actualParametersIndex = 0
            for key in parameters:
                # check types
                # print(f"Check parameter {parameters[key].annotation} with value {actualParameters[actualParametersIndex]}")
                # print(f"Type origin {typing.get_origin(parameters[key].annotation)}")
                # print(f"Type args {typing.get_args(parameters[key].annotation)}")
                # if isinstance(actualParameters[actualParametersIndex], parameters[key].annotation) :
                #
                if is_type_compatible(actualParameters[actualParametersIndex], parameters[key].annotation):
                     functionArgs[key] = actualParameters[actualParametersIndex]
                else:
                    # print(f"Incompatible type of formal parameter {parameters[key].annotation} with actual parameter {actualParameters[actualParametersIndex]}")
                    return None
                actualParametersIndex += 1
            # execute function
            try:
                # print(f"Passing {functionArgs} to {functionCode_name}")
                functionOutput = functionCode_F(**functionArgs)
                return functionOutput
            except Exception as e:
                # print(e)
                # raise RuntimeError(f"Error occurred during execution of the defined function '{functionCode_name}': {e}") from e
                return None
        else:
            return None

    except TypeError as e:
        # Catch type errors during the function *call* (e.g., wrong number/type of args)
        print(e)
        raise TypeError(f"Error calling the defined function '{functionCode_name}' with provided arguments: {e}") from e
    except Exception as e:
        # Catch other errors during function execution (e.g., NameError inside the function)
        print(e)
        raise RuntimeError(f"Error occurred during execution of the defined function '{functionCode_name}': {e}") from e


# apply pre-condition on generated test cases input and remove failing test cases
def checkPreCondition(tc: [], preCondition: str) -> bool or None:
    # iterate over test suite
    # print(f"Test case to filter: {tc}")
    # execute pre condition
    out = executeFunction(preCondition, tc)
    if isinstance(out, bool):
            return(out)
    return None

# extend test case with sut output
def computePrograOutput(tc: [], program: str) -> []:
    # print(f"Test case to compute: {tc}")
    out = executeFunction(program, tc)
    tc.insert(0, out)
    return  tc

# test posticondition
def checkPostCondition(tc: [], postCondition: str) -> bool or None:
    # print(f"Test case to check post: {tc}")
    out = executeFunction(postCondition, tc)
    return out
    # if isinstance(out, bool):
    #   return out
    # return None

# remove duplicates from a TC
def removeDuplicatedTCs(L1: typing.List[typing.Any]) -> typing.List[typing.Any]:
  L2 = []
  for item in L1:
    # The 'in' operator on a list performs sequential comparison using '=='
    # This works for nested lists and other unhashable types.
    if item not in L2:
      L2.append(item)
  return L2


if __name__ == "__main__":

    # HE1
    # prog = "def Pr_HE1(s:str) -> list[str] :\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in s:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result"
    # pre = "def check_pre_solution_HE1(s:str) -> bool:\n    if len([c for c in s if c != '(' and c!=')']) > 0 :\n        return False\n    stack = 0 # keep track of how many '(' found so far wich have not been closed\n    for c in s:\n        if c == ')' and stack==0: return False\n        elif c == ')':\n            stack = stack-1\n        else :\n            stack = stack+1\n    return stack == 0"
    # post = "def check_post_solution_HE1(r:list[str], s:str) -> bool:\n    z = [c for c in s if c != ' ']\n    if len(z) == 0 : return len(r) == 0\n\n    def ok(segment:str) -> bool:\n        if len(segment) == 0 : return False\n        if len([c for c in segment if c != '(' and c!=')']) > 0 :\n            return False\n        stack = 0 # keep track of how many '(' found so far wich have not been closed\n        while len(segment) > 0 :\n            c = segment[0]\n            segment = segment[1:]\n            if c == ')' and stack==0: return False\n            elif c == ')':\n                stack = stack-1\n                if stack == 0 and len(segment)>0 : return False\n            else :\n                stack = stack+1\n        return stack == 0\n\n\n    return  all([ok(segment) for segment in r]) and  ''.join(r) == ''.join(z)"
    # testSuite = [ ["\x0c)x./~Z9E(+e`dz"], [None], [""], ['()'] ]

    # HE0
    #pre = ""
    #prog = "def Pr_HE0(z:list[float], a:float) -> bool :\n    for idx, elem in enumerate(z):\n        for idx2, elem2 in enumerate(z):\n            if idx != idx2:\n                if elem + elem2 > a:\n                    return True\n\n    return False"
    #post = "def check_post_solution_HE0(r:bool, z:list[float], a:float) -> bool :\n    N = len(z)\n    expected = any([ any([ z[i] + z[k] > a\n                         for k in range(N) if k!=i ])\n                 for i in range(N)])\n    return r == expected"
    #testSuite = [ [[],0], ["F", ":W|M6%hY(%%,VRuSn8js"]]

    # HE127
    # prog = "def Pr_HE127(s:list[tuple[int,int]]) -> tuple[int,int] :\n    if len(s)==0:\n        return None\n    x = s[0][0]\n    y = s[0][1]\n    for (a,b) in s:\n        x = max(x,a)\n        y = min(y,b)\n    return (x,y) if x<=y else None"
    # pre = "def check_pre_solution_HE127(s:list[tuple[int,int]]) -> bool:\n    return all([a<=b for (a,b) in s])"
    # post = "def check_post_solution_HE127(r:tuple[int,int], s:list[tuple[int,int]]) -> bool:\n    if len(s)==0:\n        return r==None\n    a = max([a for (a,b) in s])\n    b = min([b for (a,b) in s])\n    return r==None if a>b else r==(a,b)"
    # testSuite = [ [[]] , [[(1,1),(1,1)]]]
    #
    #
    # for tc in testSuite:
    #     print(f"Test case {tc}")
    #     preCheck = checkPreCondition(tc, pre)
    #     print(f"Pre check is {preCheck}")
    #     tcOut = computePrograOutput(tc, prog)
    #     print(f"Out is {tcOut}")
    #     postCeck = checkPostCondition(tcOut,post)
    #     print(f"Post is {postCeck}")

    typ = int
    val = 846.713

    print(f"{isinstance(val, typ)} and {is_type_compatible(val,typ)}")
    print(f"{typ(val) }")